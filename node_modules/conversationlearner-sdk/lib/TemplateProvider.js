"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const fs = require("fs");
const path = require("path");
const CLDebug_1 = require("./CLDebug");
class TemplateProvider {
    // TODO: Decouple template renderer from types from Action classes
    // E.g. use generic key,value object instead of RenderedActionArgument
    static RenderTemplate(templateName, templateArguments) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let template = this.GetTemplate(templateName);
            if (template == null) {
                return null;
            }
            let templateString = JSON.stringify(template);
            let argumentNames = this.GetArgumentNames(templateString);
            // Substitute argument values
            for (let argumentName of argumentNames) {
                let renderedActionArgument = templateArguments.find(a => a.parameter == argumentName);
                if (renderedActionArgument) {
                    templateString = templateString.replace(new RegExp(`{{${argumentName}}}`, 'g'), renderedActionArgument.value || '');
                }
            }
            templateString = this.RemoveEmptyArguments(templateString);
            return JSON.parse(templateString);
        });
    }
    static GetTemplates() {
        let templates = [];
        let files = this.GetTemplatesNames();
        for (let file of files) {
            let fileContent = this.GetTemplate(file);
            // Clear submit check (will the set by extracting template variables)
            this.hasSubmitError = false;
            let tvs = this.UniqueTemplateVariables(fileContent);
            // Make sure template has submit item
            let validationError = this.hasSubmitError
                ? `Template "${file}" has an "Action.Submit" item but no submit data.  Submit item must be of the form: "type": "Action.Submit", "data": { "submit": "{SUBMIT PAYLOAD"}` : null;
            let templateBody = JSON.stringify(fileContent);
            let template = {
                name: file,
                variables: tvs,
                body: templateBody,
                validationError: validationError
            };
            templates.push(template);
        }
        return templates;
    }
    static UniqueTemplateVariables(template) {
        // Get all template variables
        let templateVariables = this.GetTemplateVariables(template);
        // Make entries unique, and use verion with existing type
        let unique = [];
        for (let tv of templateVariables) {
            let existing = unique.find(i => i.key == tv.key);
            if (existing) {
                if (existing.type != null && tv.type != null && existing.type != tv.type) {
                    CLDebug_1.CLDebug.Error(`Template variable "${tv.key}" used for two diffent types - "${tv.type}" and "${existing.type}".  Ignoring.`);
                }
                else {
                    existing.type = existing.type || tv.type;
                }
            }
            else {
                unique.push(tv);
            }
        }
        return unique;
    }
    static RemoveEmptyArguments(formString) {
        return formString.replace(/{{\s*[\w\.]+\s*}}/g, '');
    }
    static GetArgumentNames(formString) {
        // Get set of unique entities
        let mustaches = formString.match(/{{\s*[\w\.]+\s*}}/g);
        if (mustaches) {
            let entities = [...new Set(mustaches.map(x => x.match(/[\w\.]+/)[0]))];
            return entities;
        }
        return [];
    }
    static TemplateDirectory() {
        //TODO - make this configurable
        let templateDirectory = path.join(process.cwd(), './cards');
        // Try up a directory or two as could be in /lib or /dist folder depending on deployment
        if (!fs.existsSync(templateDirectory)) {
            templateDirectory = path.join(process.cwd(), '../cards');
        }
        if (!fs.existsSync(templateDirectory)) {
            templateDirectory = path.join(process.cwd(), '../../cards');
        }
        return templateDirectory;
    }
    static GetTemplate(templateName) {
        const filename = path.join(this.TemplateDirectory(), `${templateName}.json`);
        try {
            const templateString = fs.readFileSync(filename, 'utf-8');
            try {
                const template = JSON.parse(templateString);
                return template;
            }
            catch (_a) {
                CLDebug_1.CLDebug.Error(`Invalid JSON: Failed to Parse template named "${templateName}"`);
                return null;
            }
        }
        catch (_b) {
            CLDebug_1.CLDebug.Error(`Can't find template named: "${filename}"`);
        }
    }
    static GetTemplatesNames() {
        try {
            let fileNames = fs.readdirSync(this.TemplateDirectory());
            fileNames = fileNames.filter(fn => fn.endsWith('.json'));
            let templates = fileNames.map(f => f.slice(0, f.lastIndexOf('.')));
            return templates;
        }
        catch (_a) {
            CLDebug_1.CLDebug.Log("No Card directory found");
            return [];
        }
    }
    static GetVarNames(template) {
        let mustaches = [];
        for (let i in template) {
            if (typeof template[i] != 'object') {
                let searchStr = JSON.stringify(template[i]);
                let results = searchStr.match(/{{\s*[\w\.]+\s*}}/g);
                if (results) {
                    mustaches = mustaches.concat(results.map(x => x.match(/[\w\.]+/)[0]));
                }
            }
        }
        return mustaches;
    }
    static GetTemplateVariables(template) {
        let tvs = [];
        if (template && template.type === "Action.Submit" && (!template.data || !template.data.submit)) {
            this.hasSubmitError = true;
        }
        // Get variable names
        let vars = this.GetVarNames(template);
        if (vars.length > 0) {
            for (let key of vars) {
                let tv = { key: key, type: template['type'] };
                tvs.push(tv);
            }
        }
        // Iterate through keys
        for (let i in template) {
            if (!template.hasOwnProperty(i)) {
                continue;
            }
            if (template[i] instanceof Array) {
                for (let item of template[i]) {
                    tvs = tvs.concat(this.GetTemplateVariables(item));
                }
            }
            else if (typeof template[i] == 'object') {
                tvs = tvs.concat(this.GetTemplateVariables(template[i]));
            }
        }
        return tvs;
    }
}
TemplateProvider.hasSubmitError = false;
exports.TemplateProvider = TemplateProvider;
//# sourceMappingURL=TemplateProvider.js.map