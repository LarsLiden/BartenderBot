"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const fs = require("async-file");
const file = require("fs");
const filenamify = require("filenamify");
/**
 * :package: **botbuilder**
 *
 * A file based storage provider. Items will be persisted to a folder on disk.
 *
 * **Usage Example**
 *
 * ```JavaScript
 * const { FileStorage } = require('botbuilder');
 * const path = require('path');
 *
 * const storage = new FileStorage(path.join(__dirname, './state'));
 * ```
 */
class FileStorage {
    /**
     * Creates a new FileStorage instance.
     * @param path Root filesystem path for where the provider should store its items.
     */
    constructor(filePath) {
        this.path = filePath;
    }
    read(keys) {
        return this.ensureFolder().then(() => {
            const data = {};
            const promises = [];
            for (const iKey in keys) {
                const key = keys[iKey];
                const filePath = this.getFilePath(key);
                const p = parseFile(filePath).then((obj) => {
                    if (obj) {
                        data[key] = obj;
                    }
                });
                promises.push(p);
            }
            return Promise.all(promises).then(() => data);
        });
    }
    write(changes) {
        return this.ensureFolder()
            .then(() => {
            let promises = [];
            for (const key in changes) {
                let filePath = this.getFilePath(key);
                promises.push(fs.exists(filePath)
                    .then((exists) => {
                    let newObj = Object.assign({}, changes[key]);
                    newObj.eTag = (parseInt(newObj.eTag || '0', 10) + 1).toString();
                    return fs.writeTextFile(filePath, JSON.stringify(newObj));
                }));
            }
            return Promise.all(promises).then(() => undefined);
        });
    }
    ;
    delete(keys) {
        return this.ensureFolder().then(() => {
            const promises = [];
            for (let iKey in keys) {
                const key = keys[iKey];
                const filePath = this.getFilePath(key);
                const p = fs.exists(filePath).then((exists) => {
                    if (exists) {
                        file.unlinkSync(filePath);
                    }
                });
                promises.push(p);
            }
            Promise.all(promises).then(() => undefined);
        });
    }
    ensureFolder() {
        if (!this.pEnsureFolder) {
            this.pEnsureFolder = fs.exists(this.path).then((exists) => {
                if (!exists) {
                    return fs.mkdirp(this.path);
                }
                return;
            });
        }
        return this.pEnsureFolder;
    }
    getFileName(key) {
        return filenamify(key);
    }
    getFilePath(key) {
        return path.join(this.path, this.getFileName(key));
    }
}
FileStorage.nextTag = 0;
exports.FileStorage = FileStorage;
function parseFile(filePath) {
    return fs.exists(filePath)
        .then((exists) => exists ? fs.readTextFile(filePath) : Promise.resolve(undefined))
        .then((data) => {
        try {
            if (data) {
                return JSON.parse(data);
            }
        }
        catch (err) {
            console.warn(`FileStorage: error parsing "${filePath}": ${err.toString()}`);
        }
        return undefined;
    })
        .catch((err) => {
        console.warn(`FileStorage: error reading "${filePath}": ${err.toString()}`);
        return undefined;
    });
}
//# sourceMappingURL=FileStorage.js.map