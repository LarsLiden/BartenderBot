"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const request = require("request");
const conversationlearner_models_1 = require("conversationlearner-models");
class Utils {
    static SendTyping(adapter, address) {
        /* TODO
        let msg = <builder.IMessage>{ type: 'typing'};
        msg.address = address;
        bot.post(msg);
        */
    }
    // TEMP: Until we re-jigger object types.  Need to be stripped
    static StripPrebuiltInfoFromTrain(trainDialog) {
        return {
            trainDialogId: trainDialog.trainDialogId,
            sourceLogDialogId: trainDialog.sourceLogDialogId,
            version: trainDialog.version,
            packageCreationId: trainDialog.packageCreationId,
            packageDeletionId: trainDialog.packageDeletionId,
            rounds: trainDialog.rounds.map(r => ({
                scorerSteps: r.scorerSteps,
                extractorStep: this.StripPrebuiltInfo(r.extractorStep)
            }))
        };
    }
    // TEMP: Until we re-jigger object types.  Need to be stripped
    static StripPrebuiltInfo(trainExtractorStep) {
        return {
            textVariations: trainExtractorStep.textVariations.map(tv => ({
                text: tv.text,
                labelEntities: tv.labelEntities.map(le => {
                    let nle = Object.assign({}, le);
                    delete nle.builtinType;
                    delete nle.resolution;
                    return nle;
                })
            }))
        };
    }
    /** Trick to get errors to render on Azure */
    static ReplaceErrors(key, value) {
        if (value instanceof Error) {
            const error = {};
            Object.getOwnPropertyNames(value).forEach(k => {
                error[k] = value[k];
            });
            return error;
        }
        return value;
    }
    /** Handle that catch clauses can be any type */
    static ErrorString(error, context = '') {
        let prefix = context ? `${context}: ` : '';
        try {
            if (!error) {
                return prefix + 'Unknown';
            }
            else if (!error.body) {
                if (typeof error == 'string') {
                    return prefix + error;
                }
                else {
                    return prefix + JSON.stringify(error, this.ReplaceErrors);
                }
            }
            else if (error.body.message) {
                return prefix + error.body.message;
            }
            else if (error.body.errorMessages) {
                return prefix + error.body.errorMessages.join();
            }
            else if (typeof error.body == 'string') {
                return prefix + error.body;
            }
            else {
                return prefix + JSON.stringify(error.body);
            }
        }
        catch (e) {
            return prefix + `Error Parsing Failed`; //: ${Object.prototype.toString.call(e)} ${JSON.stringify(e)}`;
        }
    }
    static ReadFromFile(url) {
        return new Promise((resolve, reject) => {
            const requestData = {
                url: url,
                json: true,
                encoding: 'utf8'
            };
            request.get(requestData, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else if (response.statusCode && response.statusCode >= 300) {
                    reject(body.message);
                }
                else {
                    let model = String.fromCharCode.apply(null, body.data);
                    resolve(model);
                }
            });
        });
    }
    static PrebuiltDisplayText(prebuiltType, resolution, entityText) {
        if (prebuiltType.startsWith('builtin.encyclopedia')) {
            return entityText;
        }
        switch (prebuiltType) {
            case 'builtin.datetimeV2.date':
                let date = resolution.values[0].value;
                if (resolution.values[1]) {
                    date += ` or ${resolution.values[1].value}`;
                }
                return date;
            case 'builtin.datetimeV2.time':
                let time = resolution.values[0].value;
                if (resolution.values[1]) {
                    time += ` or ${resolution.values[1].value}`;
                }
                return time;
            case 'builtin.datetimeV2.daterange':
                return `${resolution.values[0].start} to ${resolution.values[0].end}`;
            case 'builtin.datetimeV2.timerange':
                return `${resolution.values[0].start} to ${resolution.values[0].end}`;
            case 'builtin.datetimeV2.datetimerange':
                return `${resolution.values[0].start} to ${resolution.values[0].end}`;
            case 'builtin.datetimeV2.duration':
                return `${resolution.values[0].value} seconds`;
            case 'builtin.datetimeV2.set':
                return `${resolution.values[0].value}`;
            case 'builtin.number':
                return resolution.value;
            case 'builtin.ordinal':
                return resolution.value;
            case 'builtin.temperature':
                return resolution.value;
            case 'builtin.dimension':
                return resolution.value;
            case 'builtin.money':
                return resolution.value;
            case 'builtin.age':
                return resolution.value;
            case 'builtin.percentage':
                return resolution.value;
            case 'builtin.geography.city':
                return resolution.value;
            case 'builtin.geography.country':
                return resolution.value;
            case 'builtin.geography.pointOfInterest':
                return resolution.value;
            case 'builtin.encyclopedia':
                return entityText;
            default:
                return entityText;
        }
    }
}
exports.Utils = Utils;
const convertToMapById = (entityMap) => {
    const map = Object.keys(entityMap.map).reduce((newMap, key) => {
        const filledEntity = entityMap.map[key];
        if (!filledEntity.entityId) {
            throw new Error(`Cannot convert filledEntityMap by name to filledEntityMap by id because id does not exist for entity: ${key}`);
        }
        newMap[filledEntity.entityId] = filledEntity;
        return newMap;
    }, {});
    return new conversationlearner_models_1.FilledEntityMap({ map });
};
exports.addEntitiesById = (valuesByName) => {
    const valuesById = convertToMapById(valuesByName);
    const map = Object.assign({}, valuesByName.map, valuesById.map);
    return new conversationlearner_models_1.FilledEntityMap({ map });
};
function replace(xs, updatedX, getId) {
    const index = xs.findIndex(x => getId(x) === getId(updatedX));
    if (index < 0) {
        throw new Error(`You attempted to replace item in list with id: ${getId(updatedX)} but no item could be found.  Perhaps you meant to add the item to the list or it was already removed.`);
    }
    return [...xs.slice(0, index), updatedX, ...xs.slice(index + 1)];
}
exports.replace = replace;
function generateGUID() {
    let d = new Date().getTime();
    let guid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, char => {
        let r = ((d + Math.random() * 16) % 16) | 0;
        d = Math.floor(d / 16);
        return (char == 'x' ? r : (r & 0x3) | 0x8).toString(16);
    });
    return guid;
}
exports.generateGUID = generateGUID;
exports.CL_DEVELOPER = 'ConversationLearnerDeveloper';
exports.DEFAULT_MAX_SESSION_LENGTH = 20 * 60 * 1000; // 20 minutes
//# sourceMappingURL=Utils.js.map