/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
import * as BB from 'botbuilder';
import { CLMemory } from './CLMemory';
import { CLClient } from './CLClient';
import * as CLM from '@conversationlearner/models';
import { ClientMemoryManager } from './Memory/ClientMemoryManager';
import { CLRecognizerResult } from './CLRecognizeResult';
export interface ISessionStartParams {
    inTeach: boolean;
    isContinued: boolean;
}
export declare class CLRunner {
    private static Runners;
    private static UIRunner;
    clClient: CLClient;
    adapter: BB.BotAdapter;
    private appId;
    private maxTimeout;
    apiCallbacks: {
        [name: string]: (memoryManager: ClientMemoryManager, ...args: string[]) => Promise<Partial<BB.Activity> | string | void>;
    };
    apiParams: CLM.CallbackAPI[];
    static Create(appId: string | undefined, maxTimeout: number | undefined, client: CLClient): CLRunner;
    static Get(appId: string): CLRunner;
    private constructor();
    onTurn(turnContext: BB.TurnContext, next: () => Promise<void>): Promise<void>;
    recognize(turnContext: BB.TurnContext, force?: boolean): Promise<CLRecognizerResult | null>;
    SetAdapter(adapter: BB.BotAdapter, conversationReference: Partial<BB.ConversationReference>): void;
    private AddInput(turnContext);
    private StartSessionAsync(memory, user, appId, saveToLog, packageId);
    private GetApp(memory, inEditingUI);
    InitSessionAsync(clMemory: CLMemory, sessionId: string, logDialogId: string | null, conversationId: string | null, params: ISessionStartParams, orgSessionId?: string | null): Promise<void>;
    EndSessionAsync(key: string): Promise<void>;
    private ProcessInput(activity, conversationReference);
    private ProcessFormData(request, clMemory, appId);
    Score(appId: string, sessionId: string, memory: CLMemory, text: string, predictedEntities: CLM.PredictedEntity[], allEntities: CLM.EntityBase[], inTeach: boolean): Promise<CLM.ScoredAction>;
    entityDetectionCallback: (text: string, memoryManager: ClientMemoryManager) => Promise<void>;
    onSessionStartCallback: (memoryManager: ClientMemoryManager) => Promise<void>;
    onSessionEndCallback: (memoryManager: ClientMemoryManager) => Promise<void>;
    AddAPICallback(name: string, target: (memoryManager: ClientMemoryManager, ...args: string[]) => Promise<Partial<BB.Activity> | string | void>): void;
    private GetArguments(func);
    private ProcessPredictedEntities(text, memory, predictedEntities, allEntities);
    CallEntityDetectionCallback(text: string, predictedEntities: CLM.PredictedEntity[], memory: CLMemory, allEntities: CLM.EntityBase[]): Promise<CLM.ScoreInput>;
    CallSessionStartCallback(memory: CLMemory, appId: string | null): Promise<void>;
    CallSessionEndCallback(memory: CLMemory, appId: string | null): Promise<void>;
    RenderTemplateAsync(conversationReference: Partial<BB.ConversationReference>, clRecognizeResult: CLRecognizerResult, inTeach?: boolean): Promise<Partial<BB.Activity> | string | null>;
    SendIntent(intent: CLRecognizerResult, inTeach?: boolean): Promise<void>;
    SendMessage(memory: CLMemory, message: string | Partial<BB.Activity>, incomingActivityId?: string | undefined): Promise<void>;
    TakeLocalAPIAction(apiAction: CLM.ApiAction, filledEntityMap: CLM.FilledEntityMap, memory: CLMemory, allEntities: CLM.EntityBase[]): Promise<Partial<BB.Activity> | string | null>;
    TakeTextAction(textAction: CLM.TextAction, filledEntityMap: CLM.FilledEntityMap): Promise<Partial<BB.Activity> | string>;
    TakeCardAction(cardAction: CLM.CardAction, filledEntityMap: CLM.FilledEntityMap): Promise<Partial<BB.Activity> | string>;
    private EntityDiscrepancy(userInput, round, memory, entities);
    isActionAvailable(action: CLM.ActionBase, filledEntities: CLM.FilledEntity[]): boolean;
    /** Convert list of filled entities into a filled entity map lookup table */
    private CreateFilledEntityMap(filledEntities, entityList);
    /**
     * Identify any validation issues
     * Missing Entities
     * Missing Actions
     * Unavailble Actions
     */
    DialogValidationErrors(trainDialog: CLM.TrainDialog, entities: CLM.EntityBase[], actions: CLM.ActionBase[]): string[];
    /** Return a list of trainDialogs that are invalid for the given set of entities and actions */
    validateTrainDialogs(appDefinition: CLM.AppDefinition): string[];
    /** Get Activites generated by trainDialog.
     * NOTE: Will set bot memory to state at end of history
     */
    GetHistory(appId: string, trainDialog: CLM.TrainDialog, userName: string, userId: string, memory: CLMemory, ignoreLastExtract?: boolean): Promise<CLM.TeachWithHistory | null>;
    private APICard(apiAction);
}
