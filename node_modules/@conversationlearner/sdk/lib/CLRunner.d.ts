/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
import * as BB from 'botbuilder';
import { CLMemory } from './CLMemory';
import { CLClient } from './CLClient';
import * as CLM from '@conversationlearner/models';
import { ReadOnlyClientMemoryManager, ClientMemoryManager } from './Memory/ClientMemoryManager';
import { CLRecognizerResult } from './CLRecognizeResult';
export declare enum SessionStartFlags {
    NONE = 0,
    IN_TEACH = 1,
    IS_EDIT_CONTINUE = 2,
    IS_MANUAL_TIMEOUT = 4
}
export interface InternalCallback<T> extends CLM.Callback, ICallback<T> {
}
/**
 * Processes messages received from the user. Called by the dialog system.
 */
export declare type EntityDetectionCallback = (text: string, memoryManager: ClientMemoryManager) => Promise<void>;
/**
 * Called at session start.
 * Allows bot to set initial entities before conversation begins
 */
export declare type OnSessionStartCallback = (context: BB.TurnContext, memoryManager: ClientMemoryManager) => Promise<void>;
/**
 * Called when Session ends.
 * If not implemented all entity values will be cleared.
 * If implemented, developer may return a list of entities to preserve for the next session
 * as well as store them in the Bot State
 */
export declare type OnSessionEndCallback = (context: BB.TurnContext, memoryManager: ClientMemoryManager, sessionEndState: CLM.SessionEndState, data: string | undefined) => Promise<string[] | void>;
/**
 * Called when the associated action in your bot is sent.
 * Common use cases are to call external APIs to gather data and save into entities for usage later.
 */
export declare type LogicCallback<T> = (memoryManager: ClientMemoryManager, ...args: string[]) => Promise<T | void>;
export declare const defaultLogicCallback: () => Promise<void>;
/**
 * Called when the associated action in your bot is sent AND during dialog replay.
 * Common use cases are to construct text or card messages based on current entity values.
 */
export declare type RenderCallback<T> = (logicResult: T, memoryManager: ReadOnlyClientMemoryManager, ...args: string[]) => Promise<Partial<BB.Activity> | string>;
export declare const defaultRenderCallback: (x: string | Partial<BB.Activity>) => Promise<string | Partial<BB.Activity>>;
export interface ICallbackInput<T> {
    name: string;
    logic?: LogicCallback<T>;
    render?: RenderCallback<T>;
}
interface ICallback<T> {
    name: string;
    logic: LogicCallback<T>;
    render: RenderCallback<T>;
}
declare enum ActionInputType {
    LOGIC_ONLY = 0,
    RENDER_ONLY = 1,
    LOGIC_AND_RENDER = 2
}
interface IActionInputLogic {
    type: ActionInputType.RENDER_ONLY;
    value: string | undefined;
}
interface IActionInputRenderOnly {
    type: ActionInputType;
}
declare type IActionInput = IActionInputRenderOnly | IActionInputLogic;
export interface IActionResult {
    logicResult: object | void;
    response: Partial<BB.Activity> | string | null;
}
export declare type CallbackMap = {
    [name: string]: InternalCallback<any>;
};
export declare class CLRunner {
    private static Runners;
    private static UIRunner;
    clClient: CLClient;
    adapter: BB.BotAdapter | undefined;
    private configModelId;
    private maxTimeout;
    callbacks: CallbackMap;
    static Create(configModelId: string | undefined, maxTimeout: number | undefined, client: CLClient): CLRunner;
    static GetRunnerForUI(appId?: string): CLRunner;
    private constructor();
    onTurn(turnContext: BB.TurnContext, next: () => Promise<void>): Promise<void>;
    recognize(turnContext: BB.TurnContext, force?: boolean): Promise<CLRecognizerResult | null>;
    InTrainingUI(turnContext: BB.TurnContext): Promise<boolean>;
    BotStartSession(turnContext: BB.TurnContext): Promise<void>;
    SetAdapter(adapter: BB.BotAdapter, conversationReference: Partial<BB.ConversationReference>): void;
    private AddInput;
    StartSessionAsync(clMemory: CLMemory, conversationId: string | null, appId: string, sessionStartFlags: SessionStartFlags, createParams: CLM.SessionCreateParams | CLM.CreateTeachParams): Promise<CLM.Teach | CLM.Session>;
    private GetRunningApp;
    EndSessionAsync(key: string, sessionEndState: CLM.SessionEndState, originalSessionId?: string | null, data?: string): Promise<void>;
    private ProcessInput;
    private ProcessFormData;
    Score(appId: string, sessionId: string, memory: CLMemory, text: string, predictedEntities: CLM.PredictedEntity[], allEntities: CLM.EntityBase[], inTeach: boolean): Promise<CLM.ScoredAction>;
    entityDetectionCallback: EntityDetectionCallback | undefined;
    onSessionStartCallback: OnSessionStartCallback | undefined;
    onSessionEndCallback: OnSessionEndCallback | undefined;
    AddCallback<T>(callback: ICallbackInput<T>): void;
    private GetArguments;
    private ProcessPredictedEntities;
    CallEntityDetectionCallback(text: string, predictedEntities: CLM.PredictedEntity[], clMemory: CLMemory, allEntities: CLM.EntityBase[]): Promise<CLM.ScoreInput>;
    private CreateMemoryManagerAsync;
    CheckSessionStartCallback(clMemory: CLMemory, entities: CLM.EntityBase[]): Promise<void>;
    CheckSessionEndCallback(clMemory: CLMemory, entities: CLM.EntityBase[], sessionEndState: CLM.SessionEndState, data?: string): Promise<void>;
    RenderTemplateAsync(conversationReference: Partial<BB.ConversationReference>, clRecognizeResult: CLRecognizerResult, channelData: {} | null): Promise<IActionResult>;
    SendIntent(intent: CLRecognizerResult, channelData?: {} | null): Promise<IActionResult | undefined>;
    SendMessage(memory: CLMemory, message: string | Partial<BB.Activity>, incomingActivityId?: string | undefined): Promise<void>;
    private GetRenderedArguments;
    TakeAPIAction(apiAction: CLM.ApiAction, filledEntityMap: CLM.FilledEntityMap, clMemory: CLMemory, allEntities: CLM.EntityBase[], inTeach: boolean, actionInput: IActionInput): Promise<IActionResult>;
    TakeTextAction(textAction: CLM.TextAction, filledEntityMap: CLM.FilledEntityMap): Promise<Partial<BB.Activity> | string>;
    TakeCardAction(cardAction: CLM.CardAction, filledEntityMap: CLM.FilledEntityMap): Promise<Partial<BB.Activity> | string>;
    TakeSessionAction(sessionAction: CLM.SessionAction, filledEntityMap: CLM.FilledEntityMap, inTeach: boolean, userId: string, sessionId: string | null): Promise<Partial<BB.Activity> | null>;
    isActionAvailable(action: CLM.ActionBase, filledEntities: CLM.FilledEntity[]): boolean;
    /** Convert list of filled entities into a filled entity map lookup table */
    private CreateFilledEntityMap;
    /**
     * Identify any validation issues
     * Missing Entities
     * Missing Actions
     * Unavailable Actions
     */
    DialogValidationErrors(trainDialog: CLM.TrainDialog, entities: CLM.EntityBase[], actions: CLM.ActionBase[]): string[];
    /** Return a list of trainDialogs that are invalid for the given set of entities and actions */
    validateTrainDialogs(appDefinition: CLM.AppDefinition): string[];
    /** Populate prebuilt information in predicted entities given filled entity array */
    private PopulatePrebuilts;
    /**
     * Provide dummy data for any missing entities so they can still be rendered
     */
    private PopulateMissingFilledEntities;
    /**
     * Initialize memory for replay
     */
    private InitReplayMemory;
    /**
     * Replay a TrainDialog, calling EntityDetection callback and API Logic,
     * recalculating FilledEntities along the way
     */
    ReplayTrainDialogLogic(trainDialog: CLM.TrainDialog, clMemory: CLMemory, cleanse: boolean): Promise<CLM.TrainDialog>;
    /**
     * Get Activities generated by trainDialog.
     * Return any errors in TrainDialog
     * NOTE: Will set bot memory to state at end of history
     */
    GetHistory(trainDialog: CLM.TrainDialog, userName: string, userId: string, clMemory: CLMemory): Promise<CLM.TeachWithHistory | null>;
    private APICard;
}
export {};
