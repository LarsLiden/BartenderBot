"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const CLDebug_1 = require("./CLDebug");
const Request = require("request");
const constants = require("./constants");
const requestMethodMap = new Map([
    ['GET', Request.get],
    ['PUT', Request.put],
    ['POST', Request.post],
    ['DELETE', Request.delete]
]);
class CLClient {
    constructor(options) {
        this.options = options;
        if (options.APIM_SUBSCRIPTION_KEY === undefined) {
            options.APIM_SUBSCRIPTION_KEY = options.LUIS_AUTHORING_KEY;
        }
    }
    ValidationErrors() {
        let errors = [];
        if (typeof this.options.CONVERSATION_LEARNER_SERVICE_URI !== 'string' || this.options.CONVERSATION_LEARNER_SERVICE_URI.length === 0) {
            errors.push(`CONVERSATION_LEARNER_SERVICE_URI must be a non-empty string. You passed: ${this.options.CONVERSATION_LEARNER_SERVICE_URI}`);
        }
        if (typeof this.options.LUIS_AUTHORING_KEY !== 'string' || this.options.LUIS_AUTHORING_KEY.length === 0) {
            errors.push(`LUIS_AUTHORING_KEY must be a non-empty string. You passed: ${this.options.LUIS_AUTHORING_KEY}`);
        }
        return errors;
    }
    LuisAuthoringKey() {
        return this.options.LUIS_AUTHORING_KEY;
    }
    BuildURL(baseUri, apiPath, query) {
        let uri = baseUri + (!baseUri.endsWith('/') ? '/' : '') + apiPath;
        if (query) {
            uri += `?${query}`;
        }
        return uri;
    }
    MakeURL(apiPath, query) {
        return this.BuildURL(this.options.CONVERSATION_LEARNER_SERVICE_URI, apiPath, query);
    }
    MakeSessionURL(apiPath, query) {
        // check if request is bypassing cognitive services APIM
        if (!this.options.CONVERSATION_LEARNER_SERVICE_URI.includes('api.cognitive.microsoft.com')) {
            // In this case we are not chaning the serviceUrl and it stays the same,
            // for example: https://localhost:37936/api/v1/ -> https://localhost:37936/api/v1/
            return this.MakeURL(apiPath, query);
        }
        // The base uri for session API in cognitive services APIM is in the form of '<service url>/conversationlearner/session/v1.0/'
        // Session API are the following api:
        //  1) POST /app/<appId>/session
        //  2) PUT /app/<appId>/session/extract
        //  3) PUT /app/<appId>/session/score
        //  4) DELETE /app/<appId>/session
        let baseUri = this.options.CONVERSATION_LEARNER_SERVICE_URI.endsWith('/') ?
            this.options.CONVERSATION_LEARNER_SERVICE_URI :
            `${this.options.CONVERSATION_LEARNER_SERVICE_URI}/`;
        const apimVersionSuffix = '/v1.0/';
        if (baseUri.endsWith(apimVersionSuffix)) {
            // In this case, serviceurl has api version information in it; "session" will be inserted before /v1.0
            // this means that https://westus.api.cognitive.microsoft.com/conversationlearner/v1.0/ becomes
            // https://westus.api.cognitive.microsoft.com/conversationlearner/session/v1.0/
            baseUri = `${baseUri.substring(0, baseUri.lastIndexOf(apimVersionSuffix))}/session${apimVersionSuffix}`;
        }
        else {
            // When api version information is not part of the serviceUrl, we simply add /session/ to end of the api
            // example: https://westus.api.cognitive.microsoft.com/conversationlearner/ -> https://westus.api.cognitive.microsoft.com/conversationlearner/session/
            baseUri += 'session/';
        }
        return this.BuildURL(baseUri, apiPath, query);
    }
    send(method, url, body) {
        return new Promise((resolve, reject) => {
            const requestData = {
                url,
                headers: {
                    [constants.luisAuthoringKeyHeader]: this.options.LUIS_AUTHORING_KEY,
                    [constants.luisSubscriptionKeyHeader]: this.options.LUIS_SUBSCRIPTION_KEY,
                    // This is only used when directly targeting service.  In future APIM will provide user/subscription id associated from LUIS key
                    [constants.apimSubscriptionIdHeader]: this.options.LUIS_AUTHORING_KEY,
                    [constants.apimSubscriptionKeyHeader]: this.options.APIM_SUBSCRIPTION_KEY
                },
                json: true,
                body
            };
            CLDebug_1.CLDebug.LogRequest(method, url, requestData);
            const requestMethod = requestMethodMap.get(method);
            if (!requestMethod) {
                throw new Error(`Request method not found for http verb: ${method}`);
            }
            requestMethod(requestData, (error, response, responseBody) => {
                if (error) {
                    reject(error);
                }
                else if (response.statusCode && response.statusCode >= 300) {
                    reject(response);
                }
                else {
                    resolve(responseBody);
                }
            });
        });
    }
    //==============================================================================
    // App
    //=============================================================================
    /**
     * Retrieve information about a specific application
     * If the app ID isn't found in the set of (non-archived) apps,
     * returns 404 error ("not found")
     */
    GetApp(appId) {
        let apiPath = `app/${appId}`;
        return this.send('GET', this.MakeURL(apiPath));
    }
    GetAppSource(appId, packageId) {
        let apiPath = `app/${appId}/source?package=${packageId}`;
        return this.send('GET', this.MakeURL(apiPath));
    }
    PostAppSource(appId, appDefinition) {
        let apiPath = `app/${appId}/source`;
        return this.send('POST', this.MakeURL(apiPath), appDefinition)
            // tslint:disable-next-line:no-empty
            .then(response => { });
    }
    /** Retrieve a list of (active) applications */
    GetApps(query) {
        let apiPath = `apps`;
        return this.send('GET', this.MakeURL(apiPath, query));
    }
    /** Create a new application */
    CopyApps(srcUserId, destUserId, appId, luisSubscriptionKey) {
        const apiPath = `apps/copy?srcUserId=${srcUserId}&destUserId=${destUserId}&appId=${appId}&luisSubscriptionKey=${luisSubscriptionKey}`;
        return this.send('POST', this.MakeURL(apiPath));
    }
    /**
     * Archive an existing application
     * Note: "deleting" an application doesn't destroy it, but rather archives
     * it for a period (eg 30 days).  During the archive period, the application
     * can be restored with the next API call.  At the end of the archive period,
     * the application is destroyed.
     */
    ArchiveApp(appId) {
        let apiPath = `app/${appId}`;
        return this.send('DELETE', this.MakeURL(apiPath));
    }
    /**
     * Create a new application
     */
    // TODO: Fix API to return full object
    AddApp(app, query) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const apiPath = `app`;
            // Note: This isn't an actual AppBase, but just { appId, packageId }
            const appResponse = yield this.send('POST', this.MakeURL(apiPath, query), app);
            return appResponse.appId;
        });
    }
    /** Creates a new package tag */
    PublishApp(appId, tagName) {
        let apiPath = `app/${appId}/publish?version=${tagName}`;
        return this.send('PUT', this.MakeURL(apiPath));
    }
    /** Sets a package tags as the live version */
    PublishProdPackage(appId, packageId) {
        let apiPath = `app/${appId}/publish/${packageId}`;
        return this.send('POST', this.MakeURL(apiPath));
    }
    //==============================================================================
    // Entity
    //=============================================================================
    /**
     * Retrieves definitions of ALL entities in the latest package
     * (or the specified package, if provided).  To retrieve just the IDs
     * of all entities, see the GetEntityIds method
     */
    GetEntities(appId, query) {
        let apiPath = `app/${appId}/entities`;
        return this.send('GET', this.MakeURL(apiPath, query));
    }
    //=============================================================================
    // Log Dialogs
    //=============================================================================
    /**
     * Retrieves the contents of many/all logDialogs.
     * To retrieve just a list of IDs of all logDialogs,
     * see the GET GetLogDialogIds method.
     */
    GetLogDialogs(appId, packageIds) {
        const packages = packageIds.map(p => `package=${p}`).join("&");
        const apiPath = `app/${appId}/logdialogs?includeDefinitions=false&${packages}`;
        return this.send('GET', this.MakeURL(apiPath));
    }
    /** Runs entity extraction (prediction). */
    LogDialogExtract(appId, logDialogId, turnIndex, userInput) {
        let apiPath = `app/${appId}/logdialog/${logDialogId}/extractor/${turnIndex}`;
        // Always retrieve entity list
        let query = 'includeDefinitions=true';
        return this.send('PUT', this.MakeURL(apiPath, query), userInput);
    }
    //=============================================================================
    // Train Dialogs
    //=============================================================================
    /**
     * Retrieves information about a specific trainDialog in the current package
     * (or the specified package, if provided)
     */
    GetTrainDialog(appId, trainDialogId, includeDefinitions = false) {
        let query = `includeDefinitions=${includeDefinitions}`;
        let apiPath = `app/${appId}/traindialog/${trainDialogId}`;
        return this.send('GET', this.MakeURL(apiPath, query));
    }
    /** Runs entity extraction (prediction). */
    TrainDialogExtract(appId, trainDialogId, turnIndex, userInput) {
        let apiPath = `app/${appId}/traindialog/${trainDialogId}/extractor/${turnIndex}`;
        // Always retrieve entity list
        let query = 'includeDefinitions=true';
        return this.send('PUT', this.MakeURL(apiPath, query), userInput);
    }
    //=============================================================================
    // Session
    //=============================================================================
    /** Creates a new session and a corresponding logDialog */
    StartSession(appId, sessionCreateParams) {
        let apiPath = `app/${appId}/session`;
        return this.send('POST', this.MakeSessionURL(apiPath), sessionCreateParams);
    }
    /** Runs entity extraction (prediction). */
    SessionExtract(appId, sessionId, userInput) {
        let apiPath = `app/${appId}/session/${sessionId}/extractor`;
        // Always retrieve entity list
        let query = 'includeDefinitions=true';
        return this.send('PUT', this.MakeSessionURL(apiPath, query), userInput);
    }
    /** Take a turn and returns chosen action */
    SessionScore(appId, sessionId, scorerInput) {
        let apiPath = `app/${appId}/session/${sessionId}/scorer`;
        return this.send('PUT', this.MakeSessionURL(apiPath), scorerInput);
    }
    /** End a session. */
    EndSession(appId, sessionId) {
        let apiPath = `app/${appId}/session/${sessionId}`;
        //TODO: remove this when redundant query parameter is removed
        let query = 'saveDialog=false';
        return this.send('DELETE', this.MakeSessionURL(apiPath, query));
    }
    //=============================================================================
    // Teach
    //=============================================================================
    /** Creates a new teaching session and a corresponding trainDialog */
    StartTeach(appId, createTeachParams) {
        let apiPath = `app/${appId}/teach`;
        return this.send('POST', this.MakeURL(apiPath), createTeachParams);
    }
    /**
     * Runs entity extraction (prediction).
     * If a more recent version of the package is available on
     * the server, the session will first migrate to that newer version.  This
     * doesn't affect the trainDialog maintained.
     */
    TeachExtract(appId, teachId, userInput) {
        let apiPath = `app/${appId}/teach/${teachId}/extractor`;
        let query = 'includeDefinitions=true';
        return this.send('PUT', this.MakeURL(apiPath, query), { text: userInput.text });
    }
    /**
     * Uploads a labeled entity extraction instance
     * ie "commits" an entity extraction label, appending it to the teach session's
     * trainDialog, and advancing the dialog. This may yield produce a new package.
     */
    TeachExtractFeedback(appId, teachId, extractorStep) {
        let apiPath = `app/${appId}/teach/${teachId}/extractor`;
        return this.send('POST', this.MakeURL(apiPath), extractorStep);
    }
    /**
     * Takes a turn and return distribution over actions.
     * If a more recent version of the package is
     * available on the server, the session will first migrate to that newer version.
     * This doesn't affect the trainDialog maintained by the teaching session.
     */
    TeachScore(appId, teachId, scorerInput) {
        let apiPath = `app/${appId}/teach/${teachId}/scorer`;
        return this.send('PUT', this.MakeURL(apiPath), scorerInput);
    }
    /**
     * Uploads a labeled scorer step instance
     * – ie "commits" a scorer label, appending it to the teach session's
     * trainDialog, and advancing the dialog. This may yield produce a new package.
     */
    TeachScoreFeedback(appId, teachId, scorerResponse) {
        let apiPath = `app/${appId}/teach/${teachId}/scorer`;
        return this.send('POST', this.MakeURL(apiPath), scorerResponse);
    }
    /**
     * Ends a teach.
     * For Teach sessions, does NOT delete the associated trainDialog.
     * To delete the associated trainDialog, call DELETE on the trainDialog.
     */
    EndTeach(appId, teachId, query) {
        let apiPath = `app/${appId}/teach/${teachId}`;
        return this.send('DELETE', this.MakeURL(apiPath, query));
    }
}
exports.CLClient = CLClient;
//# sourceMappingURL=CLClient.js.map