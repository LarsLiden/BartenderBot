"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const Utils_1 = require("./Utils");
var DebugType;
(function (DebugType) {
    DebugType[DebugType["Client"] = 1] = "Client";
    DebugType[DebugType["ClientBody"] = 2] = "ClientBody";
    DebugType[DebugType["MessageQueue"] = 4] = "MessageQueue";
    DebugType[DebugType["Memory"] = 8] = "Memory";
    DebugType[DebugType["MemVerbose"] = 16] = "MemVerbose";
})(DebugType = exports.DebugType || (exports.DebugType = {}));
var LogType;
(function (LogType) {
    LogType[LogType["Log"] = 0] = "Log";
    LogType[LogType["Error"] = 1] = "Error";
})(LogType || (LogType = {}));
class CLDebug {
    static InitLogger(adapter, conversationReference) {
        CLDebug.adapter = adapter;
        CLDebug.conversationReference = conversationReference;
    }
    static HasDebugType(debugType) {
        return (debugType & this.debugType) === debugType;
    }
    static SendCache() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (CLDebug.adapter && CLDebug.cachedMessages.length > 0) {
                //TODO: Only send when running in UI
                yield CLDebug.adapter.continueConversation(CLDebug.conversationReference, (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    let cachedMessages = [...this.cachedMessages];
                    this.cachedMessages = [];
                    for (let logMessage of cachedMessages) {
                        if (logMessage.logType === LogType.Error) {
                            yield context.sendActivity({ text: logMessage.message, channelData: { highlight: "error" } });
                        }
                        else {
                            yield context.sendActivity(logMessage.message);
                        }
                    }
                }));
            }
        });
    }
    static Log(text, filter) {
        if (!filter || this.HasDebugType(filter)) {
            console.log(text);
            if (CLDebug.logToUI) {
                CLDebug.cachedMessages.push({ message: text, logType: LogType.Log });
            }
            CLDebug.SendCache();
        }
    }
    static LogRequest(method, path, payload) {
        if (this.HasDebugType(DebugType.Client)) {
            // Ignore training status messages
            if (path.indexOf('trainingstatus') > 0) {
                return;
            }
            let message = `${method} ${path}`;
            if (this.HasDebugType(DebugType.ClientBody)) {
                const formattedBody = payload.body ? JSON.stringify(payload.body, null, '  ') : '';
                if (formattedBody.length > 0) {
                    message = `${message}\n\n${formattedBody}`;
                }
            }
            console.log(message);
            if (CLDebug.logToUI) {
                CLDebug.cachedMessages.push({ message: message, logType: LogType.Log });
            }
            CLDebug.SendCache();
        }
    }
    static Error(error, context = '') {
        let text = `ERROR: ${error ? Utils_1.Utils.ErrorString(error, context) : 'No details'}`;
        console.log(text);
        CLDebug.cachedMessages.push({ message: text, logType: LogType.Error });
        CLDebug.SendCache();
        return text;
    }
    static Verbose(text) {
        if (CLDebug.verbose) {
            CLDebug.Log(`${text}`);
        }
    }
    static LogObject(obj) {
        CLDebug.Log(JSON.stringify(obj));
    }
}
CLDebug.cachedMessages = [];
CLDebug.logToUI = false; // If set all log messages displayed in chat UI, if false only error messages
CLDebug.verbose = true;
CLDebug.debugType = 0;
exports.CLDebug = CLDebug;
//# sourceMappingURL=CLDebug.js.map