"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const CLRunner_1 = require("./CLRunner");
const CLMemory_1 = require("./CLMemory");
const CLDebug_1 = require("./CLDebug");
const CLClient_1 = require("./CLClient");
const router_1 = require("./http/router");
const Utils_1 = require("./Utils");
class ConversationLearner {
    constructor(modelId, maxTimeout) {
        if (!ConversationLearner.options) {
            throw new Error("Init() must be called on ConversationLearner before instances are created");
        }
        if (typeof maxTimeout !== 'number') {
            maxTimeout = Utils_1.DEFAULT_MAX_SESSION_LENGTH;
        }
        this.clRunner = CLRunner_1.CLRunner.Create(modelId, maxTimeout, ConversationLearner.clClient);
    }
    static Init(options, storage = null) {
        ConversationLearner.options = options;
        try {
            this.clClient = new CLClient_1.CLClient(options);
            CLMemory_1.CLMemory.Init(storage);
        }
        catch (error) {
            CLDebug_1.CLDebug.Error(error, 'Conversation Learner Initialization');
        }
        return router_1.default(this.clClient, options);
    }
    recognize(turnContext, force) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.clRunner.recognize(turnContext, force);
        });
    }
    /**
     * OPTIONAL: Sessions are started automatically, StartSession call is only needed if bot needs
     * to start Conversation Learner Session with initial entity values.
     * Results in clearing of existing Entity values, and a call to the OnSessionStartCallback
     * @param turnContext BotBuilder Context
     */
    StartSession(turnContext) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.clRunner.BotStartSession(turnContext);
        });
    }
    /**
     * Provide an callback that will be invoked whenever a Session is started
     * @param target Callback of the form (context: BB.TurnContext, memoryManager: ClientMemoryManager) => Promise<void>
     */
    OnSessionStartCallback(target) {
        this.clRunner.onSessionStartCallback = target;
    }
    /**
     * Provide a callback that will be invoked whenever a Session ends.  Sessions
     * can end because of a timeout or the selection of an EndSession activity
     * @param target Callback of the form (context: BB.TurnContext, memoryManager: ClientMemoryManager, sessionEndState: CLM.SessionEndState, data: string | undefined) => Promise<string[] | undefined>
     */
    OnSessionEndCallback(target) {
        this.clRunner.onSessionEndCallback = target;
    }
    SendResult(result) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.clRunner.SendIntent(result);
        });
    }
    /** Returns true is bot is running in the Training UI
     * @param turnContext BotBuilder Context
     */
    InTrainingUI(turnContext) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // TODO: This always returns false for onConversationUpdate as 'from' is not set
            return yield this.clRunner.InTrainingUI(turnContext);
        });
    }
    /**
     * Define an API callback that can be used by the Model
     * @param callback Object with callback name, optional logic function, and optional render function.
     */
    AddCallback(callback) {
        this.clRunner.AddCallback(callback);
    }
    /** Define an Callback that will be called after Entity Detection
     * @param target Callback of the form (text: string, memoryManager: ClientMemoryManager) => Promise<void>
     */
    EntityDetectionCallback(target) {
        this.clRunner.entityDetectionCallback = target;
    }
}
ConversationLearner.options = null;
exports.ConversationLearner = ConversationLearner;
//# sourceMappingURL=ConversationLearner.js.map