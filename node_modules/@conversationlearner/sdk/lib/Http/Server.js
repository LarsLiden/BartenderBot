"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const restify = require("restify");
const errors = require("restify-errors");
const CLDebug_1 = require("../CLDebug");
const CLRunner_1 = require("../CLRunner");
const ConversationLearner_1 = require("../ConversationLearner");
const CLMemory_1 = require("../CLMemory");
const TemplateProvider_1 = require("../TemplateProvider");
const Utils_1 = require("../Utils");
const BrowserSlot_1 = require("../Memory/BrowserSlot");
const XMLDom = require("xmldom");
const models = require("@conversationlearner/models");
const corsMiddleware = require("restify-cors-middleware");
const crypto = require("crypto");
const cors = corsMiddleware({
    origins: ['*'],
    allowHeaders: ['*'],
    exposeHeaders: []
});
// Extract error text from HTML error
exports.HTML2Error = (htmlText) => {
    try {
        // Parse html
        let parser = new XMLDom.DOMParser();
        let document = parser.parseFromString(htmlText);
        let errorTitle = document.getElementById('stackpage');
        if (errorTitle && errorTitle.textContent) {
            return errorTitle.textContent.slice(0, 1500);
        }
        return htmlText;
    }
    catch (err) {
        return htmlText;
    }
};
// Parse error to return appropriate error message
exports.HandleError = (response, err) => {
    // Generate error message
    let error = '';
    if (typeof err == 'string') {
        error = err;
    }
    if (err.message && typeof err.message == 'string') {
        error += `${err.message}\n`;
    }
    if (err.stack && typeof err.stack == 'string') {
        error += `${err.stack}\n`;
    }
    if (err.body && typeof err.body == 'string') {
        // Handle HTML error
        if (err.body.indexOf('!DOCTYPE html')) {
            error += exports.HTML2Error(err.body);
        }
        else {
            error += `${err.body}\n`;
        }
    }
    if (err.statusMessage && typeof err.statusMessage == 'string') {
        error += `${err.statusMessage}\n`;
    }
    if (err.body && err.body.errorMessages && err.body.errorMessages.length > 0) {
        error += err.body.errorMessages.map((em) => JSON.stringify(em)).join();
    }
    let statusCode = err.statusCode ? err.statusCode : 500;
    response.send(statusCode, error);
    let log = `${error}\n${err.request ? 'BODY:' + err.request.body : null}`;
    CLDebug_1.CLDebug.Error(log);
};
const defaultOptions = {
    name: `SDK Service`
};
exports.createSdkServer = (client, options = {}) => {
    const server = restify.createServer(Object.assign({}, defaultOptions, options));
    server.use(restify.plugins.bodyParser());
    server.use(restify.plugins.queryParser({
        mapParams: true
    }));
    //CORS
    server.pre(cors.preflight);
    server.use(cors.actual);
    server.on('restifyError', (req, res, err, cb) => {
        CLDebug_1.CLDebug.Error(err, 'ResiftyError');
        req.log.error(err);
        return cb();
    });
    //========================================================
    // State
    //=======================================================
    /** Sets the current active application */
    server.put('state/app', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let app = req.body;
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            yield memory.SetAppAsync(app);
            res.send(200);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Sets the current conversationId so bot can send initial pro-active message */
    server.put('state/conversationId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let conversationId = req.params.id;
            let userName = req.params.username;
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            yield memory.BotState.CreateConversationReference(userName, key, conversationId);
            res.send(200);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    //========================================================
    // Bot
    //========================================================
    /** Retrieves information about the running bot */
    server.get('/bot', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let browserId = req.params.browserId;
            let clRunner = CLRunner_1.CLRunner.Get(appId);
            let apiParams = clRunner.apiParams;
            let validationErrors = clRunner.clClient.ValidationErrors();
            let browserSlot = yield BrowserSlot_1.BrowserSlot.GetSlot(browserId);
            const key = ConversationLearner_1.ConversationLearner.options.LUIS_AUTHORING_KEY;
            const hashedKey = key ? crypto.createHash('sha256').update(key).digest('hex') : "";
            const botInfo = {
                user: {
                    // We keep track that the editing  UI is running by putting this as the name of the user
                    // Can't check localhost as can be running localhost and not UI
                    name: Utils_1.CL_DEVELOPER,
                    id: `${browserSlot}-${hashedKey}`
                },
                callbacks: apiParams,
                templates: TemplateProvider_1.TemplateProvider.GetTemplates(),
                validationErrors: validationErrors
            };
            res.send(botInfo);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    //========================================================
    // App
    //========================================================
    /** Retrieves information about a specific application */
    server.get('/app/:appId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        let appId = req.params.appId;
        try {
            let app = yield client.GetApp(appId);
            res.send(app);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.get('/app/:appId/source', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const appId = req.params.appId;
        const packageId = req.params.packageId;
        try {
            const appDefinition = yield client.GetAppSource(appId, packageId);
            res.send(appDefinition);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.get('/app/:appId/trainingstatus', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const query = req.getQuery();
        const appId = req.params.appId;
        try {
            const trainingStatus = yield client.GetAppTrainingStatus(appId, query);
            res.send(trainingStatus);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Create a new application */
    server.post('/app', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let query = req.getQuery();
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let app = req.body;
            let appId = yield client.AddApp(app, query);
            app = yield client.GetApp(appId);
            res.send(app);
            // Initialize memory
            yield CLMemory_1.CLMemory.GetMemory(key).SetAppAsync(app);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /**
     * Renames an existing application or changes its LUIS key
     * Note: Renaming an application does not affect packages
     */
    server.put('/app/:appId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let query = req.getQuery();
            let app = req.body;
            if (!app.appId) {
                app.appId = req.params.appId;
            }
            else if (req.params.appId != app.appId) {
                return next(new errors.BadRequestError(`appId of object: ${app.appId} must match appId in url: ${req.params.appId}`));
            }
            let appId = yield client.EditApp(app, query);
            res.send(appId);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Archives an existing application */
    server.del('/app/:appId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let appId = req.params.appId;
            yield client.ArchiveApp(appId);
            // Did I delete my loaded app, if so clear my state
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            let app = yield memory.BotState.GetApp();
            if (app && app.appId === appId) {
                yield memory.SetAppAsync(null);
                let clRunner = CLRunner_1.CLRunner.Get(appId);
                yield clRunner.EndSessionAsync(key);
            }
            res.send(200);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /**
     * Destroys an existing application, including all its models, sessions, and logged dialogs
     * Deleting an application from the archive really destroys it – no undo.
     */
    server.del('/archive/:appId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            yield client.DeleteApp(appId);
            res.send(200);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** GET APP STATUS : Retrieves details for a specific $appId */
    server.get('/archive/:appId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let app = yield client.GetAppStatus(appId);
            res.send(app);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Retrieves a list of (active) applications */
    server.get('/apps', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let query = req.getQuery();
            let apps = yield client.GetApps(query);
            // Get lookup table for which apps packages are being edited
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            let activeApps = yield memory.BotState.GetEditingPackages();
            let uiAppList = { appList: apps, activeApps: activeApps };
            res.send(uiAppList);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Copy applications between accounts */
    server.post('/apps/copy', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        let srcUserId = req.params.srcUserId;
        let destUserId = req.params.destUserId;
        let appId = req.params.appId;
        let clRunner = CLRunner_1.CLRunner.Get(appId);
        let luisSubscriptionKey = clRunner.clClient.LuisAuthoringKey();
        if (luisSubscriptionKey == undefined) {
            throw new Error(`LUIS_AUTHORING_KEY undefined`);
        }
        try {
            let appIds = yield client.CopyApps(srcUserId, destUserId, appId, luisSubscriptionKey);
            res.send(appIds);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Retrieves a list of application Ids in the archive for the given user */
    server.get('/archive', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let query = req.getQuery();
            let apps = yield client.GetArchivedAppIds(query);
            res.send(apps);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Retrieves a list of full applications in the archive for the given user */
    server.get('/archives', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let query = req.getQuery();
            let apps = yield client.GetArchivedApps(query);
            res.send(apps);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Moves an application from the archive to the set of active applications */
    server.put('/archive/:appId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let app = yield client.RestoreApp(appId);
            res.send(app);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Creates a new package tag for an app */
    server.put('/app/:appId/publish', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let tagName = req.params.version;
            let makeLive = req.params.makeLive === "true";
            // Create tag, then load updated app
            let packageReference = yield client.PublishApp(appId, tagName);
            // Make live app if requested
            if (makeLive) {
                yield client.PublishProdPackage(appId, packageReference.packageId);
            }
            let app = yield client.GetApp(appId);
            res.send(app);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Sets the live package tag for an app */
    server.post('/app/:appId/publish/:packageId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let packageId = req.params.packageId;
            yield client.PublishProdPackage(appId, packageId);
            let app = yield client.GetApp(appId);
            res.send(app);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Sets which app package is being edited */
    server.post('/app/:appId/edit/:packageId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let appId = req.params.appId;
            let packageId = req.params.packageId;
            let app = yield client.GetApp(appId);
            if (packageId != app.devPackageId) {
                if (!app.packageVersions || !app.packageVersions.find(pv => pv.packageId == packageId)) {
                    throw new Error(`Attemped to edit package that doesn't exist: ${packageId}`);
                }
            }
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            let updatedPackageVersions = yield memory.BotState.SetEditingPackage(appId, packageId);
            res.send(updatedPackageVersions);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    //========================================================
    // Action
    //========================================================
    server.get('/app/:appId/action/:actionId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let query = req.getQuery();
            let appId = req.params.appId;
            let actionId = req.params.actionId;
            let action = yield client.GetAction(appId, actionId, query);
            res.send(action);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.post('/app/:appId/action', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let action = req.body;
            let actionId = yield client.AddAction(appId, action);
            res.send(actionId);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.put('/app/:appId/action/:actionId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let action = req.body;
            if (!action.actionId) {
                action.actionId = req.params.actionId;
            }
            else if (req.params.actionId != action.actionId) {
                return next(new errors.BadRequestError('ActionId of object does not match URI'));
            }
            let deleteEditResponse = yield client.EditAction(appId, action);
            res.send(deleteEditResponse);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Returns list of trainingDialogIds that are invalidated by the given changed action */
    server.post('/app/:appId/action/:actionId/editValidation', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let action = req.body;
            const packageId = req.params.packageId;
            if (!action.actionId) {
                action.actionId = req.params.actionId;
            }
            else if (req.params.actionId != action.actionId) {
                return next(new errors.BadRequestError('ActionId of object does not match URI'));
            }
            const appDefinition = yield client.GetAppSource(appId, packageId);
            // Replace the action with new one
            appDefinition.actions = Utils_1.replace(appDefinition.actions, action, a => a.actionId);
            let clRunner = CLRunner_1.CLRunner.Get(appId);
            let invalidTrainDialogIds = clRunner.validateTrainDialogs(appDefinition);
            res.send(invalidTrainDialogIds);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Delete action */
    server.del('/app/:appId/action/:actionId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let actionId = req.params.actionId;
            let deleteEditResponse = yield client.DeleteAction(appId, actionId);
            res.send(deleteEditResponse);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Returns list of trainDialogs invalidated by deleting the given action */
    server.get('/app/:appId/action/:actionId/deleteValidation', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let actionId = req.params.actionId;
            const packageId = req.params.packageId;
            const appDefinition = yield client.GetAppSource(appId, packageId);
            // Remove the action
            appDefinition.actions = appDefinition.actions.filter(a => a.actionId != actionId);
            let clRunner = CLRunner_1.CLRunner.Get(appId);
            let invalidTrainDialogIds = clRunner.validateTrainDialogs(appDefinition);
            res.send(invalidTrainDialogIds);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.get('/app/:appId/actions', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let query = req.getQuery();
            let appId = req.params.appId;
            let actions = yield client.GetActions(appId, query);
            res.send(actions);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.get('/app/:appId/action', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let query = req.getQuery();
            let appId = req.params.appId;
            let actions = yield client.GetActionIds(appId, query);
            res.send(actions);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    //========================================================
    // Entities
    //========================================================
    server.get('/app/:appId/entityIds', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let query = req.getQuery();
            let appId = req.params.appId;
            let actions = yield client.GetEntityIds(appId, query);
            res.send(actions);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.get('/app/:appId/entity/:entityId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let query = req.getQuery();
            let appId = req.params.appId;
            let entityId = req.params.entityId;
            let entity = yield client.GetEntity(appId, entityId, query);
            res.send(entity);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.post('/app/:appId/entity', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let entity = req.body;
            let entityId = yield client.AddEntity(appId, entity);
            res.send(entityId);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.put('/app/:appId/entity/:entityId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let entity = req.body;
            if (!entity.entityId) {
                entity.entityId = req.params.entityId;
            }
            else if (req.params.entityId != entity.entityId) {
                return next(new errors.BadRequestError('EntityId of object does not match URI'));
            }
            let entityId = yield client.EditEntity(appId, entity);
            res.send(entityId);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Returns list of trainingDialogIds that are invalidated by the given changed entity */
    server.post('/app/:appId/entity/:entityId/editValidation', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let entity = req.body;
            const packageId = req.params.packageId;
            if (!entity.entityId) {
                entity.entityId = req.params.entityId;
            }
            else if (req.params.entityId != entity.entityId) {
                return next(new errors.BadRequestError('EntityId of object does not match URI'));
            }
            const appDefinition = yield client.GetAppSource(appId, packageId);
            // Replace the entity with new one
            appDefinition.entities = Utils_1.replace(appDefinition.entities, entity, e => e.entityId);
            let clRunner = CLRunner_1.CLRunner.Get(appId);
            let invalidTrainDialogIds = clRunner.validateTrainDialogs(appDefinition);
            res.send(invalidTrainDialogIds);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.del('/app/:appId/entity/:entityId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let entityId = req.params.entityId;
            let deleteEditResponse = yield client.DeleteEntity(appId, entityId);
            res.send(deleteEditResponse);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Returns list of trainDialogs invalidated by deleting the given entity */
    server.get('/app/:appId/entity/:entityId/deleteValidation', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let entityId = req.params.entityId;
            const packageId = req.params.packageId;
            const appDefinition = yield client.GetAppSource(appId, packageId);
            // Remove the action
            appDefinition.entities = appDefinition.entities.filter(e => e.entityId != entityId);
            let clRunner = CLRunner_1.CLRunner.Get(appId);
            let invalidTrainDialogIds = clRunner.validateTrainDialogs(appDefinition);
            res.send(invalidTrainDialogIds);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.get('/app/:appId/entities', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let query = req.getQuery();
            let appId = req.params.appId;
            let entities = yield client.GetEntities(appId, query);
            res.send(entities);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.get('/app/:appId/entity', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let query = req.getQuery();
            let appId = req.params.appId;
            let entityIds = yield client.GetEntityIds(appId, query);
            res.send(entityIds);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    //========================================================
    // LogDialogs
    //========================================================
    server.get('/app/:appId/logdialog/:logDialogId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let logDialogId = req.params.logDialogId;
            let logDialog = yield client.GetLogDialog(appId, logDialogId);
            res.send(logDialog);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.del('/app/:appId/logdialog/:logDialogId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let logDialogId = req.params.logDialogId;
            yield client.DeleteLogDialog(appId, logDialogId);
            res.send(200);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.get('/app/:appId/logdialogs', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let packageId = req.params.packageId;
            let logDialogs = yield client.GetLogDialogs(appId, packageId);
            res.send(logDialogs);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.get('/app/:appId/logDialogIds', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let query = req.getQuery();
            let appId = req.params.appId;
            let logDialogIds = yield client.GetLogDialogIds(appId, query);
            res.send(logDialogIds);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    //========================================================
    // TrainDialogs
    //========================================================
    server.post('/app/:appId/traindialog', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let trainDialog = req.body;
            // TEMP: until object refactor
            let strippedTrainDialog = Utils_1.Utils.StripPrebuiltInfoFromTrain(trainDialog);
            let trainDialogId = yield client.AddTrainDialog(appId, strippedTrainDialog);
            res.send(trainDialogId);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.put('/app/:appId/traindialog/:trainDialogId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let trainDialog = req.body;
            //TEMP: until object refactor
            let strippedTrainDialog = Utils_1.Utils.StripPrebuiltInfoFromTrain(trainDialog);
            let trainDialogId = yield client.EditTrainDialog(appId, strippedTrainDialog);
            res.send(trainDialogId);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.get('/app/:appId/traindialog/:trainDialogId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let trainDialogId = req.params.trainDialogId;
            let trainDialog = yield client.GetTrainDialog(appId, trainDialogId);
            res.send(trainDialog);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.del('/app/:appId/traindialog/:trainDialogId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let trainDialogId = req.params.trainDialogId;
            yield client.DeleteTrainDialog(appId, trainDialogId);
            res.send(200);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.get('/app/:appId/traindialogs', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let query = req.getQuery();
            let appId = req.params.appId;
            let trainDialogs = yield client.GetTrainDialogs(appId, query);
            res.send(trainDialogs);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.get('/app/:appId/trainDialogIds', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let query = req.getQuery();
            let appId = req.params.appId;
            let trainDialogIds = yield client.GetTrainDialogIds(appId, query);
            res.send(trainDialogIds);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** RUN EXTRACTOR: Runs entity extraction on a train dialog
     */
    server.put('/app/:appId/traindialog/:trainDialogId/extractor/:turnIndex', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let appId = req.params.appId;
            let trainDialogId = req.params.trainDialogId;
            let turnIndex = req.params.turnIndex;
            let userInput = req.body;
            let extractResponse = yield client.TrainDialogExtract(appId, trainDialogId, turnIndex, userInput);
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            let memories = yield memory.BotMemory.DumpMemory();
            let uiExtractResponse = { extractResponse, memories };
            res.send(uiExtractResponse);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Create a new teach session based on the current train dialog starting at round turnIndex */
    server.post('/app/:appId/traindialog/:trainDialogId/branch/:turnIndex', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let appId = req.params.appId;
            let userName = req.params.username;
            let userId = req.params.userid;
            let trainDialogId = req.params.trainDialogId;
            let turnIndex = req.params.turnIndex;
            // Retreive current train dialog
            let trainDialog = yield client.GetTrainDialog(appId, trainDialogId, true);
            // Slice to length requested by user
            trainDialog.rounds = trainDialog.rounds.slice(0, turnIndex);
            // Get history and replay to put bot into last round
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            let clRunner = CLRunner_1.CLRunner.Get(appId);
            let teachWithHistory = yield clRunner.GetHistory(appId, trainDialog, userName, userId, memory);
            if (!teachWithHistory) {
                res.send(500, new Error(`Could not find teach session history for given train dialog`));
                return;
            }
            // Start teach session if replay of API was consistent
            if (teachWithHistory.replayErrors.length === 0) {
                // Start new teach session from the old train dialog
                let createTeachParams = models.ModelUtils.ToCreateTeachParams(trainDialog);
                let teachResponse = yield client.StartTeach(appId, createTeachParams);
                // Start Sesion - with "true" to save the memory from the History
                yield clRunner.InitSessionAsync(memory, teachResponse.teachId, null, null, { inTeach: true, isContinued: true });
                teachWithHistory.teach = models.ModelUtils.ToTeach(teachResponse);
            }
            res.send(teachWithHistory);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    //========================================================
    // Session
    //========================================================
    /** START SESSION : Creates a new session and a corresponding logDialog */
    server.post('/app/:appId/session', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let appId = req.params.appId;
            let sessionCreateParams = req.body;
            let sessionResponse = yield client.StartSession(appId, sessionCreateParams);
            res.send(sessionResponse);
            let clRunner = CLRunner_1.CLRunner.Get(appId);
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            clRunner.InitSessionAsync(memory, sessionResponse.sessionId, sessionResponse.logDialogId, null, { inTeach: false, isContinued: false });
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** GET SESSION : Retrieves information about the specified session */
    server.get('/app/:appId/session/:sessionId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let sessionId = req.params.sessionId;
            let response = yield client.GetSession(appId, sessionId);
            res.send(response);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** EXPIRE SESSION : Expires the current session (timeout) */
    server.put('/app/:appId/session/:sessionId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            let conversationId = yield memory.BotState.GetConversationId();
            if (!conversationId) {
                // If conversation is empty
                return;
            }
            let sessionId = yield memory.BotState.GetSessionId(conversationId);
            if (sessionId != req.params.sessionId) {
                throw new Error("Attempting to expire sessionId not in use");
            }
            // Force sesion to expire
            yield memory.BotState.SetLastActive(0);
            res.send(200);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** END SESSION : End a session. */
    server.del('/app/:appId/session/:sessionId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let appId = req.params.appId;
            let sessionId = req.params.sessionId;
            // Session may be a replacement for an expired one
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            sessionId = yield memory.BotState.OrgSessionIdAsync(sessionId);
            let response = yield client.EndSession(appId, sessionId);
            res.send(response);
            let clRunner = CLRunner_1.CLRunner.Get(appId);
            clRunner.EndSessionAsync(key);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** GET SESSIONS : Retrieves definitions of ALL open sessions */
    server.get('/app/:appId/sessions', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let query = req.getQuery();
            let appId = req.params.appId;
            let sessions = yield client.GetSessions(appId, query);
            res.send(sessions);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** GET SESSION IDS : Retrieves a list of session IDs */
    server.get('/app/:appId/session', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let query = req.getQuery();
            let appId = req.params.appId;
            let sessionIds = yield client.GetSessionIds(appId, query);
            res.send(sessionIds);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    //========================================================
    // Teach
    //========================================================
    /** START TEACH SESSION: Creates a new teaching session and a corresponding trainDialog */
    server.post('/app/:appId/teach', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let appId = req.params.appId;
            let teachResponse = yield client.StartTeach(appId, null);
            let clRunner = CLRunner_1.CLRunner.Get(appId);
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            clRunner.InitSessionAsync(memory, teachResponse.teachId, null, null, { inTeach: true, isContinued: false });
            // Include and persistent memories in the response
            let memories = yield memory.BotMemory.DumpMemory();
            let uiTeachResponse = { teachResponse, memories };
            res.send(uiTeachResponse);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Clear the bot's memory */
    server.del('/app/:appId/botmemory', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            // Update Memory
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            yield memory.BotMemory.ClearAsync();
            res.send(200);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** START TEACH SESSION: Creates a new teaching session from existing train dialog */
    server.post('/app/:appId/teachwithhistory', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let appId = req.params.appId;
            let userName = req.params.username;
            let userId = req.params.userid;
            let ignoreLastExtract = req.params.ignoreLastExtract === 'true';
            let trainDialog = req.body;
            // Get history and replay to put bot into last round
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            let clRunner = CLRunner_1.CLRunner.Get(appId);
            let teachWithHistory = yield clRunner.GetHistory(appId, trainDialog, userName, userId, memory, ignoreLastExtract);
            if (!teachWithHistory) {
                res.send(500, new Error(`Could not find teach session history for given train dialog`));
                return;
            }
            // Start session if API returned consistent results during replay
            if (teachWithHistory.replayErrors.length === 0) {
                // Start new teach session from the old train dialog
                let createTeachParams = models.ModelUtils.ToCreateTeachParams(trainDialog);
                let teachResponse = yield client.StartTeach(appId, createTeachParams);
                // Start Sesion - with "true" to save the memory from the History
                yield clRunner.InitSessionAsync(memory, teachResponse.teachId, null, null, { inTeach: true, isContinued: true });
                teachWithHistory.teach = models.ModelUtils.ToTeach(teachResponse);
                // If last action wasn't terminal need to score
                if (teachWithHistory.dialogMode === models.DialogMode.Scorer) {
                    // Get entities from my memory
                    const filledEntities = yield memory.BotMemory.FilledEntitiesAsync();
                    let scoreInput = {
                        filledEntities,
                        context: {},
                        maskedActions: []
                    };
                    teachWithHistory.scoreInput = scoreInput;
                    teachWithHistory.scoreResponse = yield client.TeachScore(appId, teachWithHistory.teach.teachId, teachWithHistory.scoreInput);
                }
            }
            res.send(teachWithHistory);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** GET TEACH: Retrieves information about the specified teach */
    server.get('/app/:appId/teach/:teachId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let appId = req.params.appId;
            let teachId = req.params.teachId;
            let teach = yield client.GetTeach(appId, teachId);
            res.send(teach);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** RUN EXTRACTOR: Runs entity extraction (prediction).
     * If a more recent version of the package is available on
     * the server, the session will first migrate to that newer version.  This
     * doesn't affect the trainDialog maintained.
     */
    server.put('/app/:appId/teach/:teachId/extractor', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let appId = req.params.appId;
            let teachId = req.params.teachId;
            let userInput = req.body;
            // If a form text could be null
            if (!userInput.text) {
                userInput.text = '  ';
            }
            let extractResponse = yield client.TeachExtract(appId, teachId, userInput);
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            let memories = yield memory.BotMemory.DumpMemory();
            let uiExtractResponse = { extractResponse, memories };
            res.send(uiExtractResponse);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** EXTRACT FEEDBACK & RUN SCORER:
     * 1) Uploads a labeled entity extraction instance
     * ie "commits" an entity extraction label, appending it to the teach session's
     * trainDialog, and advancing the dialog. This may yield produce a new package.
     * 2) Takes a turn and return distribution over actions.
     * If a more recent version of the package is
     * available on the server, the session will first migrate to that newer version.
     * This doesn't affect the trainDialog maintained by the teaching session.
     */
    server.put('/app/:appId/teach/:teachId/scorer', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let appId = req.params.appId;
            let teachId = req.params.teachId;
            let uiScoreInput = req.body;
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            // There will be no extraction step if performing a 2nd scorer round after a non-termial action
            if (uiScoreInput.trainExtractorStep) {
                // TEMP: until object scheme is revised, need to strip for server
                let trainExtractorStep = Utils_1.Utils.StripPrebuiltInfo(uiScoreInput.trainExtractorStep);
                // Send teach feedback;
                yield client.TeachExtractFeedback(appId, teachId, trainExtractorStep);
            }
            // Call LUIS callback to get scoreInput
            let extractResponse = uiScoreInput.extractResponse;
            let clRunner = CLRunner_1.CLRunner.Get(appId);
            let scoreInput = yield clRunner.CallEntityDetectionCallback(extractResponse.text, extractResponse.predictedEntities, memory, extractResponse.definitions.entities);
            // Get score response
            let scoreResponse = yield client.TeachScore(appId, teachId, scoreInput);
            let memories = yield memory.BotMemory.DumpMemory();
            let uiScoreResponse = { scoreInput, scoreResponse, memories };
            res.send(uiScoreResponse);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /**
     * Re-run scorer given previous score input
     */
    server.put('/app/:appId/teach/:teachId/rescore', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            const { appId, teachId } = req.params;
            const scoreInput = req.body;
            const memory = CLMemory_1.CLMemory.GetMemory(key);
            // Get new score response re-using scoreInput from previous score request
            const scoreResponse = yield client.TeachScore(appId, teachId, scoreInput);
            const memories = yield memory.BotMemory.DumpMemory();
            const uiScoreResponse = {
                scoreInput,
                scoreResponse,
                memories
            };
            res.send(uiScoreResponse);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** SCORE FEEDBACK: Uploads a labeled scorer step instance
     * – ie "commits" a scorer label, appending it to the teach session's
     * trainDialog, and advancing the dialog. This may yield produce a new package.
     */
    server.post('/app/:appId/teach/:teachId/scorer', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let appId = req.params.appId;
            let teachId = req.params.teachId;
            let uiTrainScorerStep = req.body;
            // Save scored action and remove from service call
            let scoredAction = uiTrainScorerStep.trainScorerStep.scoredAction;
            if (!scoredAction) {
                throw new Error(`trainScorerStep.scoredAction must be defined.`);
            }
            delete uiTrainScorerStep.trainScorerStep.scoredAction;
            let teachResponse = yield client.TeachScoreFeedback(appId, teachId, uiTrainScorerStep.trainScorerStep);
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            // Now send the trained intent
            let intent = {
                scoredAction: scoredAction,
                clEntities: uiTrainScorerStep.entities,
                memory: memory,
                inTeach: true
            };
            let clRunner = CLRunner_1.CLRunner.Get(appId);
            yield clRunner.SendIntent(intent, true);
            let memories = yield memory.BotMemory.DumpMemory();
            let uiTeachResponse = { teachResponse, memories };
            res.send(uiTeachResponse);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** END TEACH: Ends a teach.
     * For Teach sessions, does NOT delete the associated trainDialog.
     * To delete the associated trainDialog, call DELETE on the trainDialog.
     */
    server.del('/app/:appId/teach/:teachId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let appId = req.params.appId;
            let teachId = req.params.teachId;
            let save = req.params.save ? `saveDialog=${req.params.save}` : '';
            let response = yield client.EndTeach(appId, teachId, save);
            res.send(response);
            let clRunner = CLRunner_1.CLRunner.Get(appId);
            clRunner.EndSessionAsync(key);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** GET TEACH SESSOINS: Retrieves definitions of ALL open teach sessions */
    server.get('/app/:appId/teaches', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let query = req.getQuery();
            let appId = req.params.appId;
            let teaches = yield client.GetTeaches(appId, query);
            res.send(teaches);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** GET TEACH SESSION IDS: Retrieves a list of teach session IDs */
    server.get('/app/:appId/teach', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            let query = req.getQuery();
            let appId = req.params.appId;
            let teachIds = yield client.GetTeachIds(appId, query);
            res.send(teachIds);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    //========================================================
    // Replay
    //========================================================
    server.post('/app/:appId/history', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let appId = req.params.appId;
            let userName = req.params.username;
            let userId = req.params.userid;
            let trainDialog = req.body;
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            let clRunner = CLRunner_1.CLRunner.Get(appId);
            let teachWithHistory = yield clRunner.GetHistory(appId, trainDialog, userName, userId, memory);
            // Clear bot memory geneated with his
            memory.BotMemory.ClearAsync();
            if (teachWithHistory) {
                res.send(teachWithHistory);
            }
            else {
                res.send(204);
            }
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    server.post('/app/:appId/teach/:teachId/undo', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = req.header(models.MEMORY_KEY_HEADER_NAME);
            let appId = req.params.appId;
            let userName = req.params.username;
            let userId = req.params.userid;
            let popRound = req.params.popround;
            let teach = req.body;
            // Retreive current train dialog
            let trainDialog = yield client.GetTrainDialog(appId, teach.trainDialogId, true);
            // Remove last round
            if (popRound == 'true') {
                trainDialog.rounds.pop();
            }
            // Get memory and store a backup in case the undo fails
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            let memoryBackup = yield memory.BotMemory.FilledEntityMap();
            // Get history and replay to put bot into last round
            let clRunner = CLRunner_1.CLRunner.Get(appId);
            let teachWithHistory = yield clRunner.GetHistory(appId, trainDialog, userName, userId, memory);
            if (!teachWithHistory) {
                throw new Error(`Attempted to undo last action of teach session, but could not get session history`);
            }
            // If APIs returned same values during replay
            if (teachWithHistory.replayErrors.length === 0) {
                // Delete existing train dialog (don't await)
                client.EndTeach(appId, teach.teachId, `saveDialog=false`);
                // Start new teach session from the previous trainDialog
                let createTeachParams = models.ModelUtils.ToCreateTeachParams(trainDialog);
                let teachResponse = yield client.StartTeach(appId, createTeachParams);
                // Start Sesion - with "true" to save the memory from the History
                yield clRunner.InitSessionAsync(memory, teachResponse.teachId, null, null, { inTeach: true, isContinued: true });
                teachWithHistory.teach = models.ModelUtils.ToTeach(teachResponse);
            }
            else {
                // Failed, so restore the old memory
                yield memory.BotMemory.RestoreFromMap(memoryBackup);
            }
            res.send(teachWithHistory);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    return server;
};
exports.default = exports.createSdkServer;
//# sourceMappingURL=Server.js.map