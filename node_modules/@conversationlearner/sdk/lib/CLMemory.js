"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const BB = require("botbuilder");
const CLDebug_1 = require("./CLDebug");
const BotMemory_1 = require("./Memory/BotMemory");
const BotState_1 = require("./Memory/BotState");
class CLMemory {
    constructor(userkey) {
        this.memCache = {};
        this.userkey = userkey;
    }
    static Init(memoryStorage) {
        CLMemory.memoryStorage = memoryStorage;
        // If memory storage not defined use disk storage
        if (!memoryStorage) {
            CLDebug_1.CLDebug.Log('Storage not defined.  Defaulting to in-memory storage.');
            CLMemory.memoryStorage = new BB.MemoryStorage();
        }
    }
    static GetMemory(key) {
        return new CLMemory(key);
    }
    // Generate memory key from session
    static InitMemory(user, conversationReference) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!user) {
                throw new Error(`Attempted to initialize memory, but cannot get memory key because current request did not have 'from'/user specified`);
            }
            if (!user.id) {
                throw new Error(`Attempted to initialize memory, but user.id was not provided which is required for use as memory key.`);
            }
            let memory = new CLMemory(user.id);
            yield memory.BotState.SetConversationReference(conversationReference);
            return memory;
        });
    }
    Key(datakey) {
        return `${this.userkey}_${datakey}`;
    }
    GetAsync(datakey) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!CLMemory.memoryStorage) {
                throw new Error('Memory storage not found');
            }
            let key = this.Key(datakey);
            let cacheData = this.memCache[key];
            if (cacheData) {
                CLDebug_1.CLDebug.Log(`-< ${key} : ${cacheData}`, CLDebug_1.DebugType.MemVerbose);
                return cacheData;
            }
            else {
                try {
                    let data = yield CLMemory.memoryStorage.read([key]);
                    if (data[key]) {
                        this.memCache[key] = data[key].value;
                    }
                    else {
                        this.memCache[key] = null;
                    }
                    CLDebug_1.CLDebug.Log(`R< ${key} : ${this.memCache[key]}`, CLDebug_1.DebugType.Memory);
                    return this.memCache[key];
                }
                catch (err) {
                    CLDebug_1.CLDebug.Error(err);
                    return null;
                }
            }
        });
    }
    SetAsync(datakey, jsonString) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!CLMemory.memoryStorage) {
                throw new Error('Memory storage not found');
            }
            if (jsonString == "null") {
                yield this.DeleteAsync(datakey);
                return;
            }
            let key = this.Key(datakey);
            try {
                // First check mem cache to see if anything has changed, if not, can skip write
                let cacheData = this.memCache[key];
                if (cacheData == jsonString) {
                    CLDebug_1.CLDebug.Log(`-> ${key} : ${jsonString}`, CLDebug_1.DebugType.MemVerbose);
                }
                else {
                    // Write to memory storage (use * for etag)
                    yield CLMemory.memoryStorage.write({ [key]: { value: jsonString, eTag: '*' } });
                    this.memCache[key] = jsonString;
                    CLDebug_1.CLDebug.Log(`W> ${key} : ${jsonString}`, CLDebug_1.DebugType.Memory);
                }
            }
            catch (err) {
                CLDebug_1.CLDebug.Error(err);
            }
        });
    }
    DeleteAsync(datakey) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let key = this.Key(datakey);
            try {
                // TODO: Remove possibility of being null
                if (!CLMemory.memoryStorage) {
                    CLDebug_1.CLDebug.Error(`You attempted to delete key: ${key} before memoryStorage was defined`);
                }
                else {
                    CLMemory.memoryStorage.delete([key]);
                    this.memCache[key] = null;
                    CLDebug_1.CLDebug.Log(`D> ${key} : -----`, CLDebug_1.DebugType.Memory);
                }
            }
            catch (err) {
                CLDebug_1.CLDebug.Error(err);
            }
        });
    }
    SetAppAsync(app) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const curApp = yield this.BotState.GetApp();
            yield this.BotState._SetAppAsync(app);
            if (!app || !curApp || curApp.appId !== app.appId) {
                yield this.BotMemory.ClearAsync();
            }
        });
    }
    get BotMemory() {
        return BotMemory_1.BotMemory.Get(this);
    }
    get BotState() {
        return BotState_1.BotState.Get(this);
    }
}
CLMemory.memoryStorage = null;
exports.CLMemory = CLMemory;
//# sourceMappingURL=CLMemory.js.map