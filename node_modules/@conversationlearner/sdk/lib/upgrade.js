"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const models = require("@conversationlearner/models");
/**
 * Given an app definition return an updated app definition.
 * If no updates are performed, return undefined.
 */
function default_1(appDefinition, callbackMap) {
    let isChanged = false;
    const appDefinitionChanges = {
        actions: appDefinition.actions.map(a => getActionChangeResult(a, callbackMap)),
        entities: appDefinition.entities.map(getDefaultChangeResult),
        trainDialogs: appDefinition.trainDialogs.map(getDefaultChangeResult)
    };
    const actionsChanged = appDefinitionChanges.actions.some(cr => cr.isChanged);
    isChanged = isChanged || actionsChanged;
    return isChanged
        ? {
            isChanged: true,
            currentAppDefinition: appDefinition,
            updatedAppDefinition: {
                actions: appDefinitionChanges.actions.map(cr => cr.value),
                entities: appDefinitionChanges.entities.map(cr => cr.value),
                trainDialogs: appDefinitionChanges.trainDialogs.map(cr => cr.value)
            },
            appDefinitionChanges
        }
        : {
            isChanged: false,
            currentAppDefinition: appDefinition
        };
}
exports.default = default_1;
function getDefaultChangeResult(value) {
    return {
        isChanged: false,
        value,
        changes: []
    };
}
exports.getDefaultChangeResult = getDefaultChangeResult;
function getActionChangeResult(action, callbackMap) {
    // By default no update is performed
    const changeResult = {
        isChanged: false,
        value: action,
        changes: []
    };
    if (action.actionType === models.ActionTypes.API_LOCAL) {
        const untypedActionPayload = JSON.parse(action.payload);
        if (Array.isArray(untypedActionPayload.arguments)) {
            const legacyActionPayload = untypedActionPayload;
            const callback = callbackMap[legacyActionPayload.payload];
            const actionPayload = callback
                ? getActionPayload(legacyActionPayload, callback)
                : {
                    payload: legacyActionPayload.payload,
                    logicArguments: legacyActionPayload.arguments,
                    renderArguments: []
                };
            const updatedAction = Object.assign({}, action, { payload: JSON.stringify(actionPayload) });
            changeResult.isChanged = true;
            changeResult.value = updatedAction;
            changeResult.changes.push(`Payload with old format using single array of arguments was updated to use the new form with separate logic and render arguments.`);
        }
    }
    return changeResult;
}
exports.getActionChangeResult = getActionChangeResult;
function getActionPayload(legacyActionPayload, callback) {
    return legacyActionPayload.arguments.reduce((actionPayload, argument) => {
        const isMovedToLogicArgument = callback.logicArguments.some(la => la === argument.parameter);
        if (isMovedToLogicArgument) {
            actionPayload.logicArguments.push(argument);
        }
        const isMovedToRenderArgument = callback.renderArguments.some(la => la === argument.parameter);
        if (isMovedToRenderArgument) {
            actionPayload.renderArguments.push(argument);
        }
        return actionPayload;
    }, {
        payload: legacyActionPayload.payload,
        logicArguments: [],
        renderArguments: []
    });
}
exports.getActionPayload = getActionPayload;
//# sourceMappingURL=upgrade.js.map