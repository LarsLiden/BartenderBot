"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const express = require("express");
const url = require("url");
const CLDebug_1 = require("../CLDebug");
const CLRunner_1 = require("../CLRunner");
const ConversationLearner_1 = require("../ConversationLearner");
const CLMemory_1 = require("../CLMemory");
const TemplateProvider_1 = require("../TemplateProvider");
const Utils_1 = require("../Utils");
const BrowserSlot_1 = require("../Memory/BrowserSlot");
const Request = require("request");
const XMLDom = require("xmldom");
const CLM = require("@conversationlearner/models");
const crypto = require("crypto");
const proxy = require("http-proxy-middleware");
const constants = require("../constants");
const bodyParser = require("body-parser");
const cors = require("cors");
const upgrade_1 = require("../upgrade");
// Extract error text from HTML error
exports.HTML2Error = (htmlText) => {
    try {
        // Parse html
        let parser = new XMLDom.DOMParser();
        let document = parser.parseFromString(htmlText);
        let errorTitle = document.getElementById('stackpage');
        if (errorTitle && errorTitle.textContent) {
            return errorTitle.textContent.slice(0, 1500);
        }
        return htmlText;
    }
    catch (err) {
        return htmlText;
    }
};
// Parse error to return appropriate error message
exports.HandleError = (response, err) => {
    // Generate error message
    let error = '';
    if (typeof err == 'string') {
        error = err;
    }
    if (err.message && typeof err.message == 'string') {
        error += `${err.message}\n`;
    }
    if (err.stack && typeof err.stack == 'string') {
        error += `${err.stack}\n`;
    }
    if (err.body && typeof err.body == 'string') {
        // Handle HTML error
        if (err.body.includes('!DOCTYPE html')) {
            error += exports.HTML2Error(err.body);
        }
        else {
            error += `${err.body}\n`;
        }
    }
    if (err.statusMessage && typeof err.statusMessage == 'string') {
        error += `${err.statusMessage}\n`;
    }
    if (err.body && err.body.errorMessages && err.body.errorMessages.length > 0) {
        error += err.body.errorMessages.map((em) => JSON.stringify(em)).join();
    }
    let statusCode = err.statusCode ? err.statusCode : 500;
    response.status(statusCode);
    response.send(error);
    let log = `${error}\n${err.request ? 'BODY:' + err.request.body : null}`;
    CLDebug_1.CLDebug.Error(log);
};
const statusEndpoint = "https://blisstorage.blob.core.windows.net/status/status.json";
const versionEndpoint = "https://blisstorage.blob.core.windows.net/version/version.json";
const getBanner = (source) => {
    return new Promise((resolve, reject) => {
        const options = {
            method: 'GET',
            uri: source,
            json: true
        };
        // Never fail this request
        Request(options, (error, response, banner) => {
            if (error) {
                CLDebug_1.CLDebug.Error(error, `Unable to retrieve Banner message`);
                resolve(null);
            }
            else if (response.statusCode && response.statusCode >= 300) {
                CLDebug_1.CLDebug.Error(`Unable to retrieve Banner message.  Status Code: ${response.statusCode}`);
                resolve(null);
            }
            else {
                try {
                    if (banner.message === "") {
                        banner = null;
                    }
                    resolve(banner);
                }
                catch (err) {
                    CLDebug_1.CLDebug.Error("Malformed Banner message");
                    resolve(null);
                }
            }
        });
    });
};
exports.getRouter = (client, options) => {
    const router = express.Router({ caseSensitive: false });
    router.use(cors());
    router.use(bodyParser.json({
        limit: '10mb'
    }));
    router.get('/', (req, res, next) => {
        res.status(200).send({
            message: `Conversation Learner SDK: ${new Date().toJSON()}`
        });
    });
    //========================================================
    // State
    //=======================================================
    /** Sets the current active application */
    router.put('/state/app', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const app = req.body;
            const memory = CLMemory_1.CLMemory.GetMemory(key);
            yield memory.SetAppAsync(app);
            res.sendStatus(200);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Sets the current conversationId so bot can send initial pro-active message */
    router.put('/state/conversationId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const { conversationId, userName } = getQuery(req);
            const memory = CLMemory_1.CLMemory.GetMemory(key);
            yield memory.BotState.CreateConversationReference(userName, key, conversationId);
            res.sendStatus(200);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    //========================================================
    // Bot
    //========================================================
    /** Retrieves information about the running bot */
    router.get('/bot', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const { browserId, appId } = getQuery(req);
            const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
            const validationErrors = clRunner.clClient.ValidationErrors();
            // Generate id
            const browserSlot = yield BrowserSlot_1.BrowserSlot.GetSlot(browserId);
            const key = ConversationLearner_1.ConversationLearner.options.LUIS_AUTHORING_KEY;
            const hashedKey = key ? crypto.createHash('sha256').update(key).digest('hex') : "";
            const id = `${browserSlot}-${hashedKey}`;
            // Retrieve any status message
            let banner = yield getBanner(statusEndpoint);
            // If no status message, check if version update message is needed
            if (!banner) {
                // Display version banner if SDK is obsolete
                let versionBanner = yield getBanner(versionEndpoint);
                if (versionBanner && versionBanner.sdkversion) {
                    const isOld = yield Utils_1.isSDKOld(versionBanner.sdkversion);
                    if (isOld) {
                        banner = versionBanner;
                    }
                }
            }
            const convertInternalCallbackToCallback = (c) => {
                const { logic, render } = c, callback = tslib_1.__rest(c, ["logic", "render"]);
                return callback;
            };
            const botInfo = {
                user: {
                    // We keep track that the editing  UI is running by putting this as the name of the user
                    // Can't check localhost as can be running localhost and not UI
                    name: Utils_1.CL_DEVELOPER,
                    id: id
                },
                callbacks: Object.values(clRunner.callbacks).map(convertInternalCallbackToCallback),
                templates: TemplateProvider_1.TemplateProvider.GetTemplates(),
                validationErrors: validationErrors,
                banner: banner
            };
            res.send(botInfo);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    //========================================================
    // App
    //========================================================
    /** Create a new application */
    router.post('/app', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const query = url.parse(req.url).query || '';
            const key = getMemoryKey(req);
            const newApp = req.body;
            const appId = yield client.AddApp(newApp, query);
            const app = yield client.GetApp(appId);
            res.send(app);
            // Initialize memory
            yield CLMemory_1.CLMemory.GetMemory(key).SetAppAsync(app);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Archives an existing application */
    router.delete('/app/:appId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { appId } = req.params;
        try {
            const key = getMemoryKey(req);
            yield client.ArchiveApp(appId);
            // Did I delete my loaded app, if so clear my state
            const memory = CLMemory_1.CLMemory.GetMemory(key);
            const app = yield memory.BotState.GetApp();
            if (app && app.appId === appId) {
                yield memory.SetAppAsync(null);
                const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
                yield clRunner.EndSessionAsync(key, CLM.SessionEndState.OPEN);
            }
            res.sendStatus(200);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Retrieves a list of (active) applications */
    router.get('/apps', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const query = url.parse(req.url).query || '';
            const apps = yield client.GetApps(query);
            // Get lookup table for which apps packages are being edited
            const memory = CLMemory_1.CLMemory.GetMemory(key);
            const activeApps = yield memory.BotState.GetEditingPackages();
            const uiAppList = { appList: apps, activeApps: activeApps };
            res.send(uiAppList);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Copy applications between accounts */
    router.post('/apps/copy', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { srcUserId, destUserId, appId } = getQuery(req);
        const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
        const luisSubscriptionKey = clRunner.clClient.LuisAuthoringKey();
        if (luisSubscriptionKey == undefined) {
            throw new Error(`LUIS_AUTHORING_KEY undefined`);
        }
        try {
            const appIds = yield client.CopyApps(srcUserId, destUserId, appId, luisSubscriptionKey);
            res.send(appIds);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    router.get('/app/:appId/source', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { appId } = req.params;
        const { packageId } = getQuery(req);
        try {
            const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
            const appDetails = yield client.GetApp(appId);
            const appDefinition = yield client.GetAppSource(appId, packageId);
            let appDefinitionChange = upgrade_1.default(appDefinition, clRunner.callbacks);
            if (appDefinitionChange.isChanged) {
                console.warn(`⚠ Local package upgraded to enable viewing.`);
                if (packageId === appDetails.devPackageId) {
                    console.log(`⚪ Requested package id is the same the latest package id. This package is a candidate for saving.`);
                    if (packageId !== appDetails.livePackageId) {
                        console.log(`⚪ Request package id is not the live package id. Qualifies for auto upgrade.`);
                        yield client.PostAppSource(appId, appDefinitionChange.updatedAppDefinition);
                        console.log(`✔ Saved updated package successfully!`);
                        // Save the updated source and return with no change.
                        // TODO: Allow user to see that application was auto updated?
                        // The current solution hides the fact that package was updated as there isn't any useful intervention the user can do
                        // other than acknowledge and continue, but perhaps they would wish to know.
                        appDefinitionChange = {
                            isChanged: false,
                            currentAppDefinition: appDefinitionChange.updatedAppDefinition
                        };
                    }
                    else {
                        console.log(`⚠ Requested package id is also the live package id. Cannot safely auto upgrade. User must confirm in UI to save.`);
                    }
                }
            }
            res.send(appDefinitionChange);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Creates a new package tag for an app */
    router.put('/app/:appId/publish', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { appId } = req.params;
        try {
            const { version: tagName, makeLive } = getQuery(req);
            const setLive = makeLive === "true";
            // Create tag, then load updated app
            const packageReference = yield client.PublishApp(appId, tagName);
            // Make live app if requested
            if (setLive) {
                yield client.PublishProdPackage(appId, packageReference.packageId);
            }
            const app = yield client.GetApp(appId);
            res.send(app);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Sets which app package is being edited */
    router.post('/app/:appId/edit/:packageId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { appId, packageId } = req.params;
        try {
            const key = getMemoryKey(req);
            const app = yield client.GetApp(appId);
            if (packageId != app.devPackageId) {
                if (!app.packageVersions || !app.packageVersions.find(pv => pv.packageId == packageId)) {
                    throw new Error(`Attempted to edit package that doesn't exist: ${packageId}`);
                }
            }
            const memory = CLMemory_1.CLMemory.GetMemory(key);
            const updatedPackageVersions = yield memory.BotState.SetEditingPackage(appId, packageId);
            res.send(updatedPackageVersions);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    //========================================================
    // Action
    //========================================================
    /** Returns list of trainingDialogIds that are invalidated by the given changed action */
    router.post('/app/:appId/action/:actionId/editValidation', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { appId, actionId } = req.params;
        try {
            const action = req.body;
            const { packageId } = getQuery(req);
            if (!packageId) {
                res.status(400);
                res.send({ error: 'packageId query parameter must be provided' });
                return;
            }
            if (actionId !== action.actionId) {
                res.status(400);
                res.send(new Error(`ActionId in body: ${action.actionId} does not match id from URI: ${actionId}`));
                return;
            }
            const appDefinition = yield client.GetAppSource(appId, packageId);
            // Replace the action with new one
            appDefinition.actions = Utils_1.replace(appDefinition.actions, action, a => a.actionId);
            const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
            const invalidTrainDialogIds = clRunner.validateTrainDialogs(appDefinition);
            res.send(invalidTrainDialogIds);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Returns list of trainDialogs invalidated by deleting the given action */
    router.get('/app/:appId/action/:actionId/deleteValidation', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { appId, actionId } = req.params;
        try {
            const { packageId } = getQuery(req);
            const appDefinition = yield client.GetAppSource(appId, packageId);
            // Remove the action
            appDefinition.actions = appDefinition.actions.filter(a => a.actionId != actionId);
            const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
            const invalidTrainDialogIds = clRunner.validateTrainDialogs(appDefinition);
            res.send(invalidTrainDialogIds);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    //========================================================
    // Entities
    //========================================================
    /** Returns list of trainingDialogIds that are invalidated by the given changed entity */
    router.post('/app/:appId/entity/:entityId/editValidation', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { appId } = req.params;
        try {
            const entity = req.body;
            const { packageId } = getQuery(req);
            const appDefinition = yield client.GetAppSource(appId, packageId);
            // Replace the entity with new one
            appDefinition.entities = Utils_1.replace(appDefinition.entities, entity, e => e.entityId);
            const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
            const invalidTrainDialogIds = clRunner.validateTrainDialogs(appDefinition);
            res.send(invalidTrainDialogIds);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Returns list of trainDialogs invalidated by deleting the given entity */
    router.get('/app/:appId/entity/:entityId/deleteValidation', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { appId, entityId } = req.params;
        try {
            const { packageId } = getQuery(req);
            const appDefinition = yield client.GetAppSource(appId, packageId);
            // Remove the action
            appDefinition.entities = appDefinition.entities.filter(e => e.entityId != entityId);
            const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
            const invalidTrainDialogIds = clRunner.validateTrainDialogs(appDefinition);
            res.send(invalidTrainDialogIds);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    //========================================================
    // LogDialogs
    //========================================================
    /**
     * RUN EXTRACTOR: Runs entity extraction on a log dialog
     */
    router.put('/app/:appId/logdialog/:logDialogId/extractor/:turnIndex', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const { appId, logDialogId, turnIndex } = req.params;
            const userInput = req.body;
            const extractResponse = yield client.LogDialogExtract(appId, logDialogId, turnIndex, userInput);
            const memory = CLMemory_1.CLMemory.GetMemory(key);
            const memories = yield memory.BotMemory.DumpMemory();
            const uiExtractResponse = { extractResponse, memories };
            res.send(uiExtractResponse);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    router.get('/app/:appId/logdialogs', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        const { appId } = req.params;
        try {
            const { packageId } = getQuery(req);
            const packageIds = packageId.split(",");
            const logDialogs = yield client.GetLogDialogs(appId, packageIds);
            res.send(logDialogs);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    //========================================================
    // TrainDialogs
    //========================================================
    /**
     * RUN EXTRACTOR: Runs entity extraction on a train dialog
     */
    router.put('/app/:appId/traindialog/:trainDialogId/extractor/:turnIndex', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const { appId, trainDialogId, turnIndex } = req.params;
            const userInput = req.body;
            const extractResponse = yield client.TrainDialogExtract(appId, trainDialogId, turnIndex, userInput);
            const memory = CLMemory_1.CLMemory.GetMemory(key);
            const memories = yield memory.BotMemory.DumpMemory();
            const uiExtractResponse = { extractResponse, memories };
            res.send(uiExtractResponse);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Create a new teach session based on the current train dialog starting at round turnIndex */
    router.post('/app/:appId/traindialog/:trainDialogId/branch/:turnIndex', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const { username: userName, userid: userId } = getQuery(req);
            const { appId, trainDialogId, turnIndex } = req.params;
            const trainDialog = yield client.GetTrainDialog(appId, trainDialogId, true);
            // Slice to length requested by user
            trainDialog.rounds = trainDialog.rounds.slice(0, turnIndex);
            // Get history and replay to put bot into last round
            const clMemory = CLMemory_1.CLMemory.GetMemory(key);
            const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
            const teachWithHistory = yield clRunner.GetHistory(trainDialog, userName, userId, clMemory);
            if (!teachWithHistory) {
                res.status(500);
                res.send(new Error(`Could not find teach session history for given train dialog`));
                return;
            }
            // Start teach session if replay of API was consistent
            if (teachWithHistory.replayErrors.length === 0) {
                // Start new teach session from the old train dialog
                const createTeachParams = CLM.ModelUtils.ToCreateTeachParams(trainDialog);
                teachWithHistory.teach = (yield clRunner.StartSessionAsync(clMemory, null, appId, CLRunner_1.SessionStartFlags.IN_TEACH | CLRunner_1.SessionStartFlags.IS_EDIT_CONTINUE, createTeachParams));
            }
            res.send(teachWithHistory);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    // Passthrough routes
    // GET /app/:appId/traindialog/:trainDialogId
    //========================================================
    // Session
    //========================================================
    /** START SESSION : Creates a new session and a corresponding logDialog */
    router.post('/app/:appId/session', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const { appId } = req.params;
            const sessionCreateParams = req.body;
            const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
            const clMemory = CLMemory_1.CLMemory.GetMemory(key);
            const session = yield clRunner.StartSessionAsync(clMemory, null, appId, CLRunner_1.SessionStartFlags.NONE, sessionCreateParams);
            res.send(session);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** EXPIRE SESSION : Expires the current session (timeout) */
    router.put('/app/:appId/session/:sessionId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const memory = CLMemory_1.CLMemory.GetMemory(key);
            const conversationId = yield memory.BotState.GetConversationId();
            if (!conversationId) {
                // If conversation is empty
                return;
            }
            // Check that sessions match
            const curSessionId = yield memory.BotState.GetSessionIdAndSetConversationId(conversationId);
            // Session may be a replacement for an expired one
            const uiSessionId = yield memory.BotState.OrgSessionIdAsync(req.params.sessionId);
            if (curSessionId != uiSessionId) {
                throw new Error("Attempting to expire sessionId not in use");
            }
            // Force sesion to expire
            yield memory.BotState.SetLastActive(0);
            res.sendStatus(200);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** END SESSION : End a session. */
    router.delete('/app/:appId/session/:sessionId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const { appId, sessionId } = req.params;
            // Session may be a replacement for an expired one
            const memory = CLMemory_1.CLMemory.GetMemory(key);
            const originalSessionId = yield memory.BotState.OrgSessionIdAsync(sessionId);
            let response;
            if (!originalSessionId) {
                // This can happen when a LogDialog End_Session Action is called and the
                // user subsequently presses the DONE button
                response = yield client.EndSession(appId, sessionId);
                // TODO: Once log dialog interface goes away, throw error here instead
                //throw new Error(`original session id not found for session id: ${sessionId}`)
            }
            else {
                response = yield client.EndSession(appId, originalSessionId);
            }
            res.send(response);
            const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
            clRunner.EndSessionAsync(key, CLM.SessionEndState.OPEN);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    //========================================================
    // Teach
    //========================================================
    /** START TEACH SESSION: Creates a new teaching session and a corresponding trainDialog */
    router.post('/app/:appId/teach', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const { appId } = req.params;
            const initialFilledEntities = req.body || [];
            const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
            const clMemory = CLMemory_1.CLMemory.GetMemory(key);
            const createTeachParams = {
                contextDialog: [],
                initialFilledEntities
            };
            // TeachSession always starts with a clear the memory (no saved entities)
            yield clMemory.BotMemory.ClearAsync();
            const teachResponse = yield clRunner.StartSessionAsync(clMemory, null, appId, CLRunner_1.SessionStartFlags.IN_TEACH, createTeachParams);
            res.send(teachResponse);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Clear the bot's memory */
    router.delete('/app/:appId/botmemory', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            // Update Memory
            const memory = CLMemory_1.CLMemory.GetMemory(key);
            yield memory.BotMemory.ClearAsync();
            res.sendStatus(200);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** START TEACH SESSION: Creates a new teaching session from existing train dialog */
    router.post('/app/:appId/teachwithhistory', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const appId = req.params.appId;
            const { username: userName, userid: userId } = getQuery(req);
            const trainDialog = req.body.trainDialog;
            const userInput = req.body.userInput;
            // Get history and replay to put bot into last round
            const clMemory = CLMemory_1.CLMemory.GetMemory(key);
            const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
            // Replay the TrainDialog logic (API calls and EntityDetectionCallback)
            let cleanTrainDialog = yield clRunner.ReplayTrainDialogLogic(trainDialog, clMemory, true);
            const teachWithHistory = yield clRunner.GetHistory(cleanTrainDialog, userName, userId, clMemory);
            if (!teachWithHistory) {
                res.status(500);
                res.send(new Error(`Could not find teach session history for given train dialog`));
                return;
            }
            // Only start if there were no replay Errors
            if (teachWithHistory.replayErrors.length === 0) {
                // Start new teach session from the old train dialog
                const createTeachParams = CLM.ModelUtils.ToCreateTeachParams(cleanTrainDialog);
                teachWithHistory.teach = (yield clRunner.StartSessionAsync(clMemory, null, appId, CLRunner_1.SessionStartFlags.IN_TEACH | CLRunner_1.SessionStartFlags.IS_EDIT_CONTINUE, createTeachParams));
                // If last action wasn't terminal then score
                if (teachWithHistory.dialogMode === CLM.DialogMode.Scorer) {
                    // Get entities from my memory
                    const filledEntities = yield clMemory.BotMemory.FilledEntitiesAsync();
                    const scoreInput = {
                        filledEntities,
                        context: {},
                        maskedActions: []
                    };
                    teachWithHistory.scoreInput = scoreInput;
                    teachWithHistory.scoreResponse = yield client.TeachScore(appId, teachWithHistory.teach.teachId, teachWithHistory.scoreInput);
                }
                else if (userInput) {
                    // Add new input to history
                    let userActivity = CLM.ModelUtils.InputToActivity(userInput.text, userName, userId, trainDialog.rounds.length);
                    teachWithHistory.history.push(userActivity);
                    // Extract responses
                    teachWithHistory.extractResponse = yield client.TeachExtract(appId, teachWithHistory.teach.teachId, userInput);
                    teachWithHistory.dialogMode = CLM.DialogMode.Extractor;
                }
            }
            res.send(teachWithHistory);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Given a train dialog history return a score for the last round */
    router.post('/app/:appId/scorefromhistory', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const appId = req.params.appId;
            const trainDialog = req.body;
            const clMemory = CLMemory_1.CLMemory.GetMemory(key);
            const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
            // Replay the TrainDialog logic (API calls and EntityDetectionCallback)
            // and set clMemory entities for the history
            let newTrainDialog = yield clRunner.ReplayTrainDialogLogic(trainDialog, clMemory, true);
            // Start new teach session from the old train dialog
            const createTeachParams = CLM.ModelUtils.ToCreateTeachParams(newTrainDialog);
            const teach = yield clRunner.StartSessionAsync(clMemory, null, appId, CLRunner_1.SessionStartFlags.IN_TEACH | CLRunner_1.SessionStartFlags.IS_EDIT_CONTINUE, createTeachParams);
            // LARS todo  - check that round needs to be scored
            // Get entities from my memory
            const filledEntities = yield clMemory.BotMemory.FilledEntitiesAsync();
            const scoreInput = {
                filledEntities,
                context: {},
                maskedActions: []
            };
            const scoreResponse = yield client.TeachScore(appId, teach.teachId, scoreInput);
            // Delete the teach session w/o save
            yield client.EndTeach(appId, teach.teachId, `saveDialog=false`);
            const uiScoreResponse = {
                scoreResponse,
                scoreInput
            };
            res.send(uiScoreResponse);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Given a train dialog history return extraction for the last round */
    router.post('/app/:appId/extractfromhistory', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const appId = req.params.appId;
            const trainDialog = req.body.trainDialog;
            const userInput = req.body.userInput;
            const clMemory = CLMemory_1.CLMemory.GetMemory(key);
            const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
            // Replay the TrainDialog logic (API calls and EntityDetectionCallback)
            // and set clMemory entities for the history
            let newTrainDialog = yield clRunner.ReplayTrainDialogLogic(trainDialog, clMemory, true);
            // Start new teach session from the old train dialog
            const createTeachParams = CLM.ModelUtils.ToCreateTeachParams(newTrainDialog);
            const teach = yield clRunner.StartSessionAsync(clMemory, null, appId, CLRunner_1.SessionStartFlags.IN_TEACH | CLRunner_1.SessionStartFlags.IS_EDIT_CONTINUE, createTeachParams);
            // Do extraction
            const extractResponse = yield client.TeachExtract(appId, teach.teachId, userInput);
            // Delete the teach session w/o save
            yield client.EndTeach(appId, teach.teachId, `saveDialog=false`);
            res.send(extractResponse);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** Replay a train dialog */
    router.post('/app/:appId/traindialogreplay', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const appId = req.params.appId;
            const trainDialog = req.body;
            const clMemory = CLMemory_1.CLMemory.GetMemory(key);
            const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
            // Replay the TrainDialog logic (API calls and EntityDetectionCallback)
            // and set clMemory entities for the history
            let newTrainDialog = yield clRunner.ReplayTrainDialogLogic(trainDialog, clMemory, false);
            res.send(newTrainDialog);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** RUN EXTRACTOR: Runs entity extraction (prediction).
     * If a more recent version of the package is available on
     * the server, the session will first migrate to that newer version.  This
     * doesn't affect the trainDialog maintained.
     */
    router.put('/app/:appId/teach/:teachId/extractor', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const { appId, teachId } = req.params;
            const userInput = req.body;
            // If a form text could be null
            if (!userInput.text) {
                userInput.text = '  ';
            }
            const extractResponse = yield client.TeachExtract(appId, teachId, userInput);
            const memory = CLMemory_1.CLMemory.GetMemory(key);
            const memories = yield memory.BotMemory.DumpMemory();
            const uiExtractResponse = { extractResponse, memories };
            res.send(uiExtractResponse);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** EXTRACT FEEDBACK & RUN SCORER:
     * 1) Uploads a labeled entity extraction instance
     * ie "commits" an entity extraction label, appending it to the teach session's
     * trainDialog, and advancing the dialog. This may yield produce a new package.
     * 2) Takes a turn and return distribution over actions.
     * If a more recent version of the package is
     * available on the server, the session will first migrate to that newer version.
     * This doesn't affect the trainDialog maintained by the teaching session.
     */
    router.put('/app/:appId/teach/:teachId/scorer', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const { appId, teachId } = req.params;
            const uiScoreInput = req.body;
            const clMemory = CLMemory_1.CLMemory.GetMemory(key);
            // There will be no extraction step if performing a 2nd scorer round after a non-terminal action
            if (uiScoreInput.trainExtractorStep) {
                // Send teach feedback;
                yield client.TeachExtractFeedback(appId, teachId, uiScoreInput.trainExtractorStep);
            }
            // Call LUIS callback to get scoreInput
            const extractResponse = uiScoreInput.extractResponse;
            const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
            const scoreInput = yield clRunner.CallEntityDetectionCallback(extractResponse.text, extractResponse.predictedEntities, clMemory, extractResponse.definitions.entities);
            // Get score response
            const scoreResponse = yield client.TeachScore(appId, teachId, scoreInput);
            const memories = yield clMemory.BotMemory.DumpMemory();
            const uiScoreResponse = { scoreInput, scoreResponse, memories };
            res.send(uiScoreResponse);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /**
     * Re-run scorer given previous score input
     */
    router.put('/app/:appId/teach/:teachId/rescore', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const { appId, teachId } = req.params;
            const scoreInput = req.body;
            const memory = CLMemory_1.CLMemory.GetMemory(key);
            // Get new score response re-using scoreInput from previous score request
            const scoreResponse = yield client.TeachScore(appId, teachId, scoreInput);
            const memories = yield memory.BotMemory.DumpMemory();
            const uiScoreResponse = {
                scoreInput,
                scoreResponse,
                memories
            };
            res.send(uiScoreResponse);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /** SCORE FEEDBACK: Uploads a labeled scorer step instance
     * – ie "commits" a scorer label, appending it to the teach session's
     * trainDialog, and advancing the dialog. This may yield produce a new package.
     */
    router.post('/app/:appId/teach/:teachId/scorer', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const { appId, teachId } = req.params;
            const uiTrainScorerStep = req.body;
            // Save scored action and remove from service call
            const scoredAction = uiTrainScorerStep.trainScorerStep.scoredAction;
            if (!scoredAction) {
                throw new Error(`trainScorerStep.scoredAction must be defined.`);
            }
            delete uiTrainScorerStep.trainScorerStep.scoredAction;
            const memory = CLMemory_1.CLMemory.GetMemory(key);
            // Now send the trained intent
            const intent = {
                scoredAction: scoredAction,
                clEntities: uiTrainScorerStep.entities,
                memory: memory,
                inTeach: true
            };
            const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
            const actionResult = yield clRunner.SendIntent(intent, uiTrainScorerStep.channelData);
            // Set logicResult on scorer step
            if (actionResult) {
                uiTrainScorerStep.trainScorerStep.logicResult = JSON.stringify(actionResult.logicResult);
            }
            const teachResponse = yield client.TeachScoreFeedback(appId, teachId, uiTrainScorerStep.trainScorerStep);
            const memories = yield memory.BotMemory.DumpMemory();
            const isEndTask = scoredAction.actionType === CLM.ActionTypes.END_SESSION;
            const uiPostScoreResponse = { teachResponse, memories, isEndTask };
            res.send(uiPostScoreResponse);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    /**
     * END TEACH: Ends a teach.
     * For Teach sessions, does NOT delete the associated trainDialog.
     * To delete the associated trainDialog, call DELETE on the trainDialog.
     */
    router.delete('/app/:appId/teach/:teachId', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const { appId, teachId } = req.params;
            const { save } = getQuery(req);
            const saveQuery = save ? `saveDialog=${save}` : '';
            const response = yield client.EndTeach(appId, teachId, saveQuery);
            res.send(response);
            const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
            clRunner.EndSessionAsync(key, CLM.SessionEndState.OPEN);
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    //========================================================
    // Replay
    //========================================================
    router.post('/app/:appId/history', (req, res, next) => tslib_1.__awaiter(this, void 0, void 0, function* () {
        try {
            const key = getMemoryKey(req);
            const appId = req.params.appId;
            const { username: userName, userid: userId } = getQuery(req);
            const trainDialog = req.body;
            const memory = CLMemory_1.CLMemory.GetMemory(key);
            const clRunner = CLRunner_1.CLRunner.GetRunnerForUI(appId);
            const teachWithHistory = yield clRunner.GetHistory(trainDialog, userName, userId, memory);
            // Clear bot memory generated with this
            yield memory.BotMemory.ClearAsync();
            if (teachWithHistory) {
                res.send(teachWithHistory);
            }
            else {
                res.sendStatus(204);
            }
        }
        catch (error) {
            exports.HandleError(res, error);
        }
    }));
    const httpProxy = proxy({
        target: options.CONVERSATION_LEARNER_SERVICE_URI,
        changeOrigin: true,
        logLevel: 'info',
        pathRewrite: {
            '^/sdk': '/'
        },
        onProxyReq: (proxyReq, req, res) => {
            proxyReq.setHeader(constants.luisAuthoringKeyHeader, options.LUIS_AUTHORING_KEY || '');
            proxyReq.setHeader(constants.luisSubscriptionKeyHeader, options.LUIS_SUBSCRIPTION_KEY || '');
            proxyReq.setHeader(constants.apimSubscriptionIdHeader, options.LUIS_AUTHORING_KEY || '');
            proxyReq.setHeader(constants.apimSubscriptionKeyHeader, options.APIM_SUBSCRIPTION_KEY || '');
            /**
             * TODO: Find more elegant solution with middleware ordering.
             * Currently there is conflict of interest.  For the custom routes we define, we want the body parsed
             * so we need bodyParser.json() middleware above it in the pipeline; however, when bodyParser is above/before
             * the http-proxy-middleware then it can't properly stream the body through.
             *
             * This code explicitly re-streams the data by calling .write()
             *
             * Ideally we could find a way to only use bodyParser.json() on our custom routes so it's no in the pipeline above
             * the proxy
             */
            const anyReq = req;
            if (anyReq.body) {
                let bodyData = JSON.stringify(anyReq.body);
                // incase if content-type is application/x-www-form-urlencoded -> we need to change to application/json
                proxyReq.setHeader('Content-Type', 'application/json');
                proxyReq.setHeader('Content-Length', Buffer.byteLength(bodyData));
                // stream the content
                proxyReq.write(bodyData);
            }
        }
    });
    router.use(httpProxy);
    return router;
};
function getMemoryKey(req, throwError = true) {
    const key = req.header(CLM.MEMORY_KEY_HEADER_NAME);
    if (!key) {
        throw new Error(`Header ${CLM.MEMORY_KEY_HEADER_NAME} must be provided. Url: ${req.url}`);
    }
    return key;
}
function getQuery(req) {
    return url.parse(req.url, true).query || {};
}
exports.default = exports.getRouter;
//# sourceMappingURL=router.js.map