"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const BB = require("botbuilder");
const CLMemory_1 = require("./CLMemory");
const CLDebug_1 = require("./CLDebug");
const TemplateProvider_1 = require("./TemplateProvider");
const CLM = require("@conversationlearner/models");
const ClientMemoryManager_1 = require("./Memory/ClientMemoryManager");
const Utils_1 = require("./Utils");
const ConversationLearner_1 = require("./ConversationLearner");
const InputQueue_1 = require("./Memory/InputQueue");
const util = require("util");
class CLRunner {
    constructor(appId, maxTimeout, client) {
        // Mapping between user defined API names and functions
        this.apiCallbacks = {};
        this.apiParams = [];
        this.appId = appId;
        this.maxTimeout = maxTimeout;
        this.clClient = client;
    }
    static Create(appId, maxTimeout, client) {
        // Ok to not provide appId when just running in training UI 
        if (!appId) {
            appId = "UIRunner";
        }
        let newRunner = new CLRunner(appId, maxTimeout, client);
        CLRunner.Runners[appId] = newRunner;
        // Always run UI on first CL defined in the bot
        if (!CLRunner.UIRunner) {
            CLRunner.UIRunner = newRunner;
        }
        return newRunner;
    }
    // Get CLRunner for an app
    static Get(appId) {
        // If runner with the appId doesn't exist, use the UI Runner
        if (!CLRunner.Runners[appId]) {
            if (CLRunner.UIRunner) {
                return CLRunner.UIRunner;
            }
            else {
                throw new Error(`Not in UI and requested CLRunner that doesn't exist: ${appId}`);
            }
        }
        return CLRunner.Runners[appId];
    }
    onTurn(turnContext, next) {
        return this.recognize(turnContext, true)
            .then(next);
    }
    recognize(turnContext, force) {
        // Add input to queue
        return this.AddInput(turnContext).then(res => {
            return res;
        });
    }
    SetAdapter(adapter, conversationReference) {
        if (!this.adapter) {
            this.adapter = adapter;
            CLDebug_1.CLDebug.InitLogger(adapter, conversationReference);
        }
    }
    // Add input to queue.  Allows CL to handle out-of-order messages
    AddInput(turnContext) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Set adapter / conversation reference even if from field not set
            let conversationReference = BB.TurnContext.getConversationReference(turnContext.activity);
            this.SetAdapter(turnContext.adapter, conversationReference);
            if (turnContext.activity.from === undefined || turnContext.activity.id == undefined) {
                return null;
            }
            let clMemory = yield CLMemory_1.CLMemory.InitMemory(turnContext.activity.from, conversationReference);
            let botState = clMemory.BotState;
            // If I'm in teach mode process message right away
            let inTeach = yield botState.GetInTeach();
            if (inTeach) {
                return yield this.ProcessInput(turnContext.activity, conversationReference);
            }
            // Otherwise I have to queue up messages as user may input them faster than bot reponds
            else {
                let addInputPromise = util.promisify(InputQueue_1.InputQueue.AddInput);
                let isReady = yield addInputPromise(botState, turnContext.activity, conversationReference);
                if (isReady) {
                    let intents = yield this.ProcessInput(turnContext.activity, conversationReference);
                    return intents;
                }
                // Message has expired 
                return null;
            }
        });
    }
    StartSessionAsync(memory, user, appId, saveToLog, packageId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let sessionCreateParams = { saveToLog, packageId };
            let sessionResponse = yield this.clClient.StartSession(appId, sessionCreateParams);
            if (!user) {
                throw new Error(`Attempted to start session but user was not set on current request.`);
            }
            if (!user.id) {
                throw new Error(`Attempted to start session but user.id was not set on current request.`);
            }
            yield this.InitSessionAsync(memory, sessionResponse.sessionId, sessionResponse.logDialogId, user.id, { inTeach: false, isContinued: false });
            CLDebug_1.CLDebug.Verbose(`Started Session: ${sessionResponse.sessionId} - ${user.id}`);
            return sessionResponse.sessionId;
        });
    }
    // Get the currently runing app
    GetApp(memory, inEditingUI) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let app = yield memory.BotState.GetApp();
            // If I'm not in the editing UI, always use app specified by options
            if (app) {
                if (!inEditingUI && app.appId != this.appId) {
                    // Use config value
                    CLDebug_1.CLDebug.Log(`Switching to app specified in config: ${this.appId}`);
                    app = yield this.clClient.GetApp(this.appId);
                    yield memory.SetAppAsync(app);
                }
            }
            // If I don't have an app, attempt to use one set in config
            else if (this.appId) {
                CLDebug_1.CLDebug.Log(`Selecting app specified in config: ${this.appId}`);
                app = yield this.clClient.GetApp(this.appId);
                yield memory.SetAppAsync(app);
            }
            return app;
        });
    }
    // Initialize a log or teach session 
    InitSessionAsync(clMemory, sessionId, logDialogId, conversationId, params, orgSessionId = null) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let app = yield clMemory.BotState.GetApp();
            // If not continuing an edited session or restarting an expired session 
            if (!params.isContinued && !orgSessionId) {
                // If onEndSession hasn't been called yet, call it
                let calledEndSession = yield clMemory.BotState.GetEndSessionCalled();
                if (!calledEndSession) {
                    // Default callback will clear the bot memory
                    yield this.CallSessionEndCallback(clMemory, app ? app.appId : null);
                }
            }
            yield this.CallSessionStartCallback(clMemory, app ? app.appId : null);
            yield clMemory.BotState.SetSessionAsync(sessionId, logDialogId, conversationId, params.inTeach, orgSessionId);
        });
    }
    // End a teach or log session
    EndSessionAsync(key) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            let app = yield memory.BotState.GetApp();
            // Default callback will clear the bot memory
            yield this.CallSessionEndCallback(memory, app ? app.appId : null);
            yield memory.BotState.EndSessionAsync();
        });
    }
    // Proces user input
    ProcessInput(activity, conversationReference) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let errComponent = 'ProcessInput';
            // Validate request
            if (!activity.from || !activity.from.id) {
                throw new Error(`Attempted to get current session for user, but user was not defined on bot request.`);
            }
            let memory = yield CLMemory_1.CLMemory.InitMemory(activity.from, conversationReference);
            try {
                CLDebug_1.CLDebug.Verbose(`Process Input...`);
                let inTeach = yield memory.BotState.GetInTeach();
                let inEditingUI = conversationReference.user &&
                    conversationReference.user.name === Utils_1.CL_DEVELOPER || false;
                // Validate setup
                if (!inEditingUI && !this.appId) {
                    let msg = 'Must specify appId in CL constructor when not running bot in Editing UI\n\n';
                    CLDebug_1.CLDebug.Error(msg);
                    yield this.SendMessage(memory, msg, activity.id);
                    return null;
                }
                if (!ConversationLearner_1.ConversationLearner.options || !ConversationLearner_1.ConversationLearner.options.LUIS_AUTHORING_KEY) {
                    // TODO: Remove mention of environment variables. They are not guaranteed and are part of different repository.
                    let msg = 'Options must specify luisAuthoringKey.  Set the LUIS_AUTHORING_KEY.\n\n';
                    CLDebug_1.CLDebug.Error(msg);
                    yield this.SendMessage(memory, msg, activity.id);
                    return null;
                }
                let app = yield this.GetApp(memory, inEditingUI);
                if (!app) {
                    let error = "ERROR: AppId not specified.  When running in a channel (i.e. Skype) or the Bot Framework Emulator, CONVERSATION_LEARNER_APP_ID must be specified in your Bot's .env file or Application Settings on the server";
                    yield this.SendMessage(memory, error, activity.id);
                    return null;
                }
                let sessionId = yield memory.BotState.GetSessionId(activity.from.id);
                // If I'm not in teach mode
                if (!inTeach) {
                    // If if was a conversation update
                    if (activity.type == "conversationUpdate") {
                        CLDebug_1.CLDebug.Verbose(`Conversation update...  +${JSON.stringify(activity.membersAdded)} -${JSON.stringify(activity.membersRemoved)}`);
                        if (sessionId) {
                            // End the current session for user joining the conversation
                            if (activity.membersAdded &&
                                activity.from.id === activity.membersAdded[0].id) {
                                yield this.clClient.EndSession(app.appId, sessionId);
                                yield this.EndSessionAsync(activity.from.id);
                            }
                        }
                        // Ignore message (for now)
                        yield InputQueue_1.InputQueue.MessageHandled(memory.BotState, activity.id);
                        return null;
                    }
                    // Handle any other non-message input
                    else if (activity.type !== "message") {
                        yield InputQueue_1.InputQueue.MessageHandled(memory.BotState, activity.id);
                        return null;
                    }
                    if (sessionId) {
                        // If session expired, create a new one
                        const currentTicks = new Date().getTime();
                        let lastActive = yield memory.BotState.GetLastActive();
                        let passedTicks = currentTicks - lastActive;
                        if (passedTicks > this.maxTimeout) {
                            // End the current session, clear the memory
                            yield this.clClient.EndSession(app.appId, sessionId);
                            yield this.EndSessionAsync(activity.from.id);
                            // If I'm not in the UI, reload the App to get any changes (live package version may have been updated)
                            if (!inEditingUI) {
                                app = yield this.clClient.GetApp(this.appId);
                                yield memory.SetAppAsync(app);
                                if (!app) {
                                    let error = "ERROR: AppId not specified.  When running in a channel (i.e. Skype) or the Bot Framework Emulator, CONVERSATION_LEARNER_APP_ID must be specified in your Bot's .env file or Application Settings on the server";
                                    yield this.SendMessage(memory, error, activity.id);
                                    return null;
                                }
                            }
                            // Start a new session 
                            let sessionResponse = yield this.clClient.StartSession(app.appId, { saveToLog: app.metadata.isLoggingOn });
                            // Update Memory, passing in original sessionId for reference
                            let conversationId = yield memory.BotState.GetConversationId();
                            this.InitSessionAsync(memory, sessionResponse.sessionId, sessionResponse.logDialogId, conversationId, { inTeach: inTeach, isContinued: false }, sessionId);
                            // Set new sessionId
                            sessionId = sessionResponse.sessionId;
                        }
                        // Otherwise update last access time
                        else {
                            yield memory.BotState.SetLastActive(currentTicks);
                        }
                    }
                }
                // PackageId: Use live package id if not in editing UI, default to devPackage if no active package set
                let packageId = (inEditingUI ? yield memory.BotState.GetEditingPackageForApp(app.appId) : app.livePackageId) || app.devPackageId;
                if (!packageId) {
                    yield this.SendMessage(memory, "ERROR: No PackageId has been set", activity.id);
                    return null;
                }
                // If no session for this conversation (or it's expired), create a new one
                if (!sessionId) {
                    sessionId = yield this.StartSessionAsync(memory, activity.from, app.appId, app.metadata.isLoggingOn !== false, packageId);
                }
                // Process any form data
                let buttonResponse = yield this.ProcessFormData(activity, memory, app.appId);
                // Teach inputs are handled via API calls from the Conversation Learner UI
                if (!inTeach) {
                    let entities = [];
                    errComponent = 'SessionExtract';
                    let userInput = { text: buttonResponse || activity.text || '  ' };
                    let extractResponse = yield this.clClient.SessionExtract(app.appId, sessionId, userInput);
                    entities = extractResponse.definitions.entities;
                    errComponent = 'ProcessExtraction';
                    const scoredAction = yield this.Score(app.appId, sessionId, memory, extractResponse.text, extractResponse.predictedEntities, entities, inTeach);
                    return {
                        scoredAction: scoredAction,
                        clEntities: entities,
                        memory: memory,
                        inTeach: false,
                        activity: activity
                    };
                }
                return null;
            }
            catch (error) {
                CLDebug_1.CLDebug.Log(`Error during ProcessInput: ${error.message}`);
                // End the session, so use can potentially recover
                yield this.EndSessionAsync(activity.from.id);
                // Special message for 403 as it's like a bad appId
                let customError = null;
                if (error.statusCode === 403) {
                    customError = `403 Forbidden:  Please check you have set a valid CONVERSATION_LEARNER_APP_ID`;
                }
                let msg = CLDebug_1.CLDebug.Error(customError || error, errComponent);
                if (memory) {
                    yield this.SendMessage(memory, msg, activity.id);
                }
                return null;
            }
        });
    }
    ProcessFormData(request, clMemory, appId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const data = request.value;
            if (data) {
                // Get list of all entities
                let entityList = yield this.clClient.GetEntities(appId);
                // For each form entry
                for (let entityName of Object.keys(data)) {
                    // Reserved parameter
                    if (entityName == 'submit') {
                        continue;
                    }
                    // Find the entity
                    let entity = entityList.entities.find(e => e.entityName == entityName);
                    if (!entity) {
                        CLDebug_1.CLDebug.Error(`Form - Can't find Entity named: ${entityName}`);
                        return null;
                    }
                    // Set it
                    yield clMemory.BotMemory.RememberEntity(entity.entityName, entity.entityId, data[entityName], entity.isMultivalue);
                }
                // If submit type return as a response
                if (data['submit']) {
                    return data['submit'];
                }
                else {
                    CLDebug_1.CLDebug.Error(`Adaptive Card has no Sumbit data`);
                    return null;
                }
            }
            return null;
        });
    }
    Score(appId, sessionId, memory, text, predictedEntities, allEntities, inTeach) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Call LUIS callback
            let scoreInput = yield this.CallEntityDetectionCallback(text, predictedEntities, memory, allEntities);
            // Call the scorer
            let scoreResponse = null;
            if (inTeach) {
                scoreResponse = yield this.clClient.TeachScore(appId, sessionId, scoreInput);
            }
            else {
                scoreResponse = yield this.clClient.SessionScore(appId, sessionId, scoreInput);
            }
            // Get best action
            let bestAction = scoreResponse.scoredActions[0];
            // Return the action
            return bestAction;
        });
    }
    AddAPICallback(name, target) {
        this.apiCallbacks[name] = target;
        this.apiParams.push({ name, arguments: this.GetArguments(target) });
    }
    GetArguments(func) {
        const STRIP_COMMENTS = /(\/\/.*$)|(\/\*[\s\S]*?\*\/)|(\s*=[^,\)]*(('(?:\\'|[^'\r\n])*')|("(?:\\"|[^"\r\n])*"))|(\s*=[^,\)]*))/gm;
        const ARGUMENT_NAMES = /([^\s,]+)/g;
        let fnStr = func.toString().replace(STRIP_COMMENTS, '');
        let result = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES);
        if (result === null) {
            result = [];
        }
        return result.filter((f) => f !== 'memoryManager');
    }
    ProcessPredictedEntities(text, memory, predictedEntities, allEntities) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Update entities in my memory
            for (let predictedEntity of predictedEntities) {
                let entity = allEntities.find(e => e.entityId == predictedEntity.entityId);
                if (!entity) {
                    throw new Error(`Could not find entity by id: ${predictedEntity.entityId}`);
                }
                // If negative entity will have a positive counter entity
                if (entity.positiveId) {
                    yield memory.ForgetEntity(entity.entityName, predictedEntity.entityText, entity.isMultivalue);
                }
                else {
                    yield memory.RememberEntity(entity.entityName, entity.entityId, predictedEntity.entityText, entity.isMultivalue, predictedEntity.builtinType, predictedEntity.resolution);
                }
            }
        });
    }
    CallEntityDetectionCallback(text, predictedEntities, memory, allEntities) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let memoryManager = yield ClientMemoryManager_1.ClientMemoryManager.CreateAsync(memory, allEntities);
            // Update memory with predicted entities
            yield this.ProcessPredictedEntities(text, memory.BotMemory, predictedEntities, allEntities);
            // If bot has callback, call it
            if (this.entityDetectionCallback) {
                try {
                    yield this.entityDetectionCallback(text, memoryManager);
                }
                catch (err) {
                    yield this.SendMessage(memory, "Exception hit in Bot's EntityDetectionCallback");
                    let errMsg = CLDebug_1.CLDebug.Error(err);
                    this.SendMessage(memory, errMsg);
                }
            }
            // Get entities from my memory
            const filledEntities = yield memory.BotMemory.FilledEntitiesAsync();
            let scoreInput = {
                filledEntities,
                context: {},
                maskedActions: []
            };
            return scoreInput;
        });
    }
    CallSessionStartCallback(memory, appId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // If bot has callback, call it
            if (appId && this.onSessionStartCallback) {
                let entityList = yield this.clClient.GetEntities(appId);
                let memoryManager = yield ClientMemoryManager_1.ClientMemoryManager.CreateAsync(memory, entityList.entities);
                yield this.onSessionStartCallback(memoryManager);
            }
        });
    }
    CallSessionEndCallback(memory, appId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // If bot has callback, call it to determine which entites to clear / edit
            if (appId && this.onSessionEndCallback) {
                let entityList = yield this.clClient.GetEntities(appId);
                let memoryManager = yield ClientMemoryManager_1.ClientMemoryManager.CreateAsync(memory, entityList.entities);
                yield this.onSessionEndCallback(memoryManager);
            }
            // Otherwise just clear the memory
            else {
                yield memory.BotMemory.ClearAsync();
            }
        });
    }
    RenderTemplateAsync(conversationReference, clRecognizeResult) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Get filled entities from memory
            let filledEntityMap = yield clRecognizeResult.memory.BotMemory.FilledEntityMap();
            filledEntityMap = Utils_1.addEntitiesById(filledEntityMap);
            // If the action was terminal, free up the mutex allowing queued messages to be processed
            // Activity won't be present if running in training as messages aren't queued
            if (clRecognizeResult.scoredAction.isTerminal && clRecognizeResult.activity) {
                yield InputQueue_1.InputQueue.MessageHandled(clRecognizeResult.memory.BotState, clRecognizeResult.activity.id);
            }
            let message = null;
            switch (clRecognizeResult.scoredAction.actionType) {
                case CLM.ActionTypes.TEXT:
                    // This is hack to allow ScoredAction to be accepted as ActionBase
                    // TODO: Remove extra properties from ScoredAction so it only had actionId and up service to return actions definitions of scored/unscored actions
                    // so UI can link the two together instead of having "partial" actions being incorrectly treated as full actions
                    const textAction = new CLM.TextAction(clRecognizeResult.scoredAction);
                    message = yield this.TakeTextAction(textAction, filledEntityMap);
                    break;
                case CLM.ActionTypes.API_LOCAL:
                    const apiAction = new CLM.ApiAction(clRecognizeResult.scoredAction);
                    message = yield this.TakeLocalAPIAction(apiAction, filledEntityMap, clRecognizeResult.memory, clRecognizeResult.clEntities);
                    break;
                case CLM.ActionTypes.CARD:
                    const cardAction = new CLM.CardAction(clRecognizeResult.scoredAction);
                    message = yield this.TakeCardAction(cardAction, filledEntityMap);
                    break;
                default:
                    throw new Error(`Could not find matching renderer for action type: ${clRecognizeResult.scoredAction.actionType}`);
            }
            // If action wasn't terminal loop, through Conversation Learner again after a short delay
            if (!clRecognizeResult.scoredAction.isTerminal) {
                setTimeout(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    let app = yield clRecognizeResult.memory.BotState.GetApp();
                    if (!app) {
                        throw new Error(`Attempted to get current app before app was set.`);
                    }
                    const user = conversationReference.user;
                    if (!user || !user.id) {
                        throw new Error(`Attempted to get session by user id, but user was not defined on current conversation`);
                    }
                    let sessionId = yield clRecognizeResult.memory.BotState.GetSessionId(user.id);
                    if (!sessionId) {
                        throw new Error(`Attempted to get session by user id: ${user.id} but session was not found`);
                    }
                    let bestAction = yield this.Score(app.appId, sessionId, clRecognizeResult.memory, '', [], clRecognizeResult.clEntities, clRecognizeResult.inTeach);
                    // If not inTeach, send message to user
                    if (!clRecognizeResult.inTeach) {
                        clRecognizeResult.scoredAction = bestAction;
                        message = yield this.RenderTemplateAsync(conversationReference, clRecognizeResult);
                        if (message != null) {
                            this.SendMessage(clRecognizeResult.memory, message);
                        }
                    }
                }), 100);
            }
            return message;
        });
    }
    SendIntent(intent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let conversationReference = yield intent.memory.BotState.GetConversationReverence();
            if (!conversationReference) {
                CLDebug_1.CLDebug.Error('Missing ConversationReference');
                return;
            }
            let message = yield this.RenderTemplateAsync(conversationReference, intent);
            if (message != null) {
                yield this.adapter.continueConversation(conversationReference, (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    // Need to repeat null check as compiler is catching one above for explicit null
                    if (message != null) {
                        yield context.sendActivity(message);
                    }
                }));
            }
        });
    }
    SendMessage(memory, message, incomingActivityId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // If requested, pop incoming acitivty from message queue
            if (incomingActivityId) {
                yield InputQueue_1.InputQueue.MessageHandled(memory.BotState, incomingActivityId);
            }
            let conversationReference = yield memory.BotState.GetConversationReverence();
            if (!conversationReference) {
                CLDebug_1.CLDebug.Error('Missing ConversationReference');
                return;
            }
            yield this.adapter.continueConversation(conversationReference, (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield context.sendActivity(message);
            }));
        });
    }
    TakeLocalAPIAction(apiAction, filledEntityMap, memory, allEntities) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.apiCallbacks) {
                CLDebug_1.CLDebug.Error('No Local APIs defined.');
                return null;
            }
            // Extract API name and args
            const apiName = apiAction.name;
            const api = this.apiCallbacks[apiName];
            const callbackParams = this.apiParams.find(apip => apip.name == apiName);
            if (!api || !callbackParams) {
                return CLDebug_1.CLDebug.Error(`API "${apiName}" is undefined`);
            }
            // TODO: This issue arises because we only save non-null non-empty argument values on the actions
            // which means callback may accept more arguments than is actually available on the action.arguments
            // To me, it seeems it would make more sense to always have these be same length, but perhaps there is
            // dependency on action not being defined somewhere else in the application like AcionCreatorEditor
            let missingEntities = [];
            // Get arguments in order specified by the API
            const argArray = callbackParams.arguments.map((param) => {
                let argument = apiAction.arguments.find(arg => arg.parameter === param);
                if (!argument) {
                    return '';
                }
                try {
                    return argument.renderValue(CLM.getEntityDisplayValueMap(filledEntityMap));
                }
                catch (error) {
                    missingEntities.push(param);
                    return '';
                }
            }, missingEntities);
            if (missingEntities.length > 0) {
                return `ERROR: Missing Entity value(s) for ${missingEntities.join(', ')}`;
            }
            let memoryManager = yield ClientMemoryManager_1.ClientMemoryManager.CreateAsync(memory, allEntities);
            try {
                try {
                    let response = yield api(memoryManager, ...argArray);
                    return response ? response : null;
                }
                catch (err) {
                    yield this.SendMessage(memory, `Exception hit in Bot's API Callback: '${apiName}'`);
                    let errMsg = CLDebug_1.CLDebug.Error(err);
                    return errMsg;
                }
            }
            catch (err) {
                return CLDebug_1.CLDebug.Error(err);
            }
        });
    }
    TakeTextAction(textAction, filledEntityMap) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return Promise.resolve(textAction.renderValue(CLM.getEntityDisplayValueMap(filledEntityMap)));
        });
    }
    TakeCardAction(cardAction, filledEntityMap) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const entityDisplayValues = CLM.getEntityDisplayValueMap(filledEntityMap);
                const renderedArguments = cardAction.renderArguments(entityDisplayValues);
                const missingEntities = renderedArguments.filter(ra => ra.value === null);
                if (missingEntities.length > 0) {
                    return `ERROR: Missing Entity value(s) for ${missingEntities.map(me => me.parameter).join(', ')}`;
                }
                const form = yield TemplateProvider_1.TemplateProvider.RenderTemplate(cardAction.templateName, renderedArguments);
                if (form == null) {
                    return CLDebug_1.CLDebug.Error(`Missing Template: ${cardAction.templateName}`);
                }
                const attachment = BB.CardFactory.adaptiveCard(form);
                const message = BB.MessageFactory.attachment(attachment);
                message.text = undefined;
                return message;
            }
            catch (error) {
                let msg = CLDebug_1.CLDebug.Error(error, 'Failed to Render Template');
                return msg;
            }
        });
    }
    // Validate that training round memory is the same as what in the bot's memory
    // This checks that API calls didn't change when restoring the bot's state
    EntityDiscrepancy(userInput, round, memory, entities) {
        let isSame = true;
        let oldEntities = round.scorerSteps[0] && round.scorerSteps[0].input ? round.scorerSteps[0].input.filledEntities : [];
        let newEntities = Object.keys(memory.BotMemory.filledEntities.map).map(k => memory.BotMemory.filledEntities.map[k]);
        if (oldEntities.length != newEntities.length) {
            isSame = false;
        }
        else {
            for (let oldEntity of oldEntities) {
                let newEntity = newEntities.find(ne => ne.entityId == oldEntity.entityId);
                if (!newEntity) {
                    isSame = false;
                }
                else if (oldEntity.values.length != newEntity.values.length) {
                    isSame = false;
                }
                else {
                    for (let oldValue of oldEntity.values) {
                        let newValue = newEntity.values.find(v => v.userText == oldValue.userText);
                        if (!newValue) {
                            isSame = false;
                        }
                        else if (oldValue.userText !== newValue.userText) {
                            isSame = false;
                        }
                    }
                }
            }
        }
        if (isSame) {
            return null;
        }
        let originalEntities = [];
        for (let oldEntity of oldEntities) {
            const entity = entities.find(e => e.entityId == oldEntity.entityId);
            let name = entity ? entity.entityName : "MISSING ENTITY";
            let values = CLM.filledEntityValueAsString(oldEntity);
            originalEntities.push(`${name} = (${values})`);
        }
        let updatedEntities = [];
        for (let newEntity of newEntities) {
            const entity = entities.find(e => e.entityId == newEntity.entityId);
            let name = entity ? entity.entityName : "MISSING ENTITY";
            let values = CLM.filledEntityValueAsString(newEntity);
            updatedEntities.push(`${name} = (${values})`);
        }
        return new CLM.ReplayErrorEntityDiscrepancy(userInput, originalEntities, updatedEntities);
    }
    // Returns true if Action is available given Entities in Memory
    isActionAvailable(action, filledEntities) {
        for (let entityId of action.requiredEntities) {
            let found = filledEntities.find(e => e.entityId == entityId);
            if (!found) {
                return false;
            }
        }
        for (let entityId of action.negativeEntities) {
            let found = filledEntities.find(e => e.entityId == entityId);
            if (found) {
                return false;
            }
        }
        return true;
    }
    /** Convert list of filled entities into a filled entity map lookup table */
    CreateFilledEntityMap(filledEntities, entityList) {
        let filledEntityMap = new CLM.FilledEntityMap();
        for (let filledEntity of filledEntities) {
            let entity = entityList.entities.find(e => e.entityId == filledEntity.entityId);
            if (entity) {
                filledEntityMap.map[entity.entityName] = filledEntity;
                filledEntityMap.map[entity.entityId] = filledEntity;
            }
        }
        return filledEntityMap;
    }
    /**
     * Identify any validation issues
     * Missing Entities
     * Missing Actions
     * Unavailble Actions
     */
    DialogValidationErrors(trainDialog, entities, actions) {
        let validationErrors = [];
        for (let round of trainDialog.rounds) {
            let userText = round.extractorStep.textVariations[0].text;
            let filledEntities = round.scorerSteps[0] && round.scorerSteps[0].input ? round.scorerSteps[0].input.filledEntities : [];
            // Check that entities exist
            for (let fentity of filledEntities) {
                if (!entities.find(e => e.entityId == fentity.entityId)) {
                    validationErrors.push(`Missing Entity for "${CLM.filledEntityValueAsString(fentity)}"`);
                }
            }
            for (let scorerStep of round.scorerSteps) {
                let labelAction = scorerStep.labelAction;
                // Check that action exists
                let selectedAction = actions.find(a => a.actionId == labelAction);
                if (!selectedAction) {
                    validationErrors.push(`Missing Action response for "${userText}"`);
                }
                else {
                    // Check action availability
                    if (!this.isActionAvailable(selectedAction, scorerStep.input.filledEntities)) {
                        validationErrors.push(`Selected Action in unavailable in response to "${userText}"`);
                    }
                }
            }
        }
        // Make errors unique using Set operator
        validationErrors = [...new Set(validationErrors)];
        return validationErrors;
    }
    /** Return a list of trainDialogs that are invalid for the given set of entities and actions */
    validateTrainDialogs(appDefinition) {
        let invalidTrainDialogIds = [];
        for (let trainDialog of appDefinition.trainDialogs) {
            // Ignore train dialogs that are already invalid
            if (!trainDialog.invalid) {
                let validationErrors = this.DialogValidationErrors(trainDialog, appDefinition.entities, appDefinition.actions);
                if (validationErrors.length > 0) {
                    invalidTrainDialogIds.push(trainDialog.trainDialogId);
                }
            }
        }
        return invalidTrainDialogIds;
    }
    /** Get Activites generated by trainDialog.
     * NOTE: Will set bot memory to state at end of history
     */
    GetHistory(appId, trainDialog, userName, userId, memory, ignoreLastExtract = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let entities = trainDialog.definitions ? trainDialog.definitions.entities : [];
            let actions = trainDialog.definitions ? trainDialog.definitions.actions : [];
            let entityList = { entities };
            let prevMemories = [];
            // Reset the memory
            yield memory.BotMemory.ClearAsync();
            if (!trainDialog || !trainDialog.rounds) {
                return null;
            }
            let activities = [];
            let replayErrors = [];
            let isLastActionTerminal = false;
            for (let [roundNum, round] of trainDialog.rounds.entries()) {
                let userText = round.extractorStep.textVariations[0].text;
                let filledEntities = round.scorerSteps[0] && round.scorerSteps[0].input ? round.scorerSteps[0].input.filledEntities : [];
                // VALIDATION
                // Check that entities exist
                let chatHighlight = null;
                for (let fentity of filledEntities) {
                    if (!entities.find(e => e.entityId == fentity.entityId)) {
                        replayErrors.push(new CLM.ReplayErrorMissingEntity(CLM.filledEntityValueAsString(fentity)));
                        chatHighlight = "warning";
                    }
                }
                // Generate activity
                let userActivity = {
                    id: Utils_1.generateGUID(),
                    from: { id: userId, name: userName },
                    channelData: {
                        senderType: CLM.SenderType.User,
                        roundIndex: roundNum,
                        scoreIndex: 0,
                        clientActivityId: Utils_1.generateGUID(),
                        highlight: chatHighlight
                    },
                    type: 'message',
                    text: userText
                };
                activities.push(userActivity);
                // If I'm updating the bot's state, save memory before this step (used to show changes in UI)
                prevMemories = yield memory.BotMemory.DumpMemory();
                // Call entity detection callback
                let textVariation = round.extractorStep.textVariations[0];
                let predictedEntities = CLM.ModelUtils.ToPredictedEntities(textVariation.labelEntities);
                yield this.CallEntityDetectionCallback(textVariation.text, predictedEntities, memory, entities);
                // Look for discrenancies when replaying API calls
                // Unless asked to ignore the last as user trigged an edit by editing last extract step
                if (!ignoreLastExtract || roundNum != trainDialog.rounds.length - 1) {
                    let discrepancyError = this.EntityDiscrepancy(userText, round, memory, entities);
                    if (discrepancyError) {
                        replayErrors.push(discrepancyError);
                    }
                }
                for (let [scoreNum, scorerStep] of round.scorerSteps.entries()) {
                    let labelAction = scorerStep.labelAction;
                    let botResponse = null;
                    // VALIDATION
                    chatHighlight = null;
                    // Check that action exists
                    let selectedAction = actions.find(a => a.actionId == labelAction);
                    if (!selectedAction) {
                        chatHighlight = "error";
                        replayErrors.push(new CLM.ReplayErrorMissingAction(userText));
                    }
                    else {
                        // Check action availability
                        if (!this.isActionAvailable(selectedAction, scorerStep.input.filledEntities)) {
                            chatHighlight = "error";
                            replayErrors.push(new CLM.ReplayErrorActionUnavailable(userText));
                        }
                    }
                    let channelData = {
                        senderType: CLM.SenderType.Bot,
                        roundIndex: roundNum,
                        scoreIndex: scoreNum,
                        highlight: chatHighlight
                    };
                    // Generate bot response
                    let action = actions.filter((a) => a.actionId === labelAction)[0];
                    if (!action) {
                        botResponse = CLDebug_1.CLDebug.Error(`Can't find Action Id ${labelAction}`);
                    }
                    else {
                        isLastActionTerminal = action.isTerminal;
                        let filledEntityMap = this.CreateFilledEntityMap(scorerStep.input.filledEntities, entityList);
                        if (action.actionType === CLM.ActionTypes.CARD) {
                            const cardAction = new CLM.CardAction(action);
                            botResponse = yield this.TakeCardAction(cardAction, filledEntityMap);
                        }
                        else if (action.actionType === CLM.ActionTypes.API_LOCAL) {
                            const apiAction = new CLM.ApiAction(action);
                            botResponse = yield this.TakeLocalAPIAction(apiAction, filledEntityMap, memory, entityList.entities);
                            // API may not have output, but need to show something to user in WebChat do they can edit
                            if (!botResponse) {
                                botResponse = this.APICard(apiAction);
                            }
                        }
                        else if (action.actionType === CLM.ActionTypes.TEXT) {
                            const textAction = new CLM.TextAction(action);
                            botResponse = yield this.TakeTextAction(textAction, filledEntityMap);
                        }
                        // TODO
                        //  TakeAzureAPIAction
                        else {
                            throw new Error(`Cannont construct bot response for unknown action type: ${action.actionType}`);
                        }
                    }
                    let botActivity = null;
                    if (typeof botResponse == 'string') {
                        botActivity = {
                            id: Utils_1.generateGUID(),
                            from: { id: CLM.CL_USER_NAME_ID, name: CLM.CL_USER_NAME_ID, role: BB.RoleTypes.Bot },
                            type: 'message',
                            text: botResponse,
                            channelData: channelData
                        };
                    }
                    else if (botResponse) {
                        botActivity = botResponse;
                        botActivity.id = Utils_1.generateGUID();
                        botActivity.from = { id: CLM.CL_USER_NAME_ID, name: CLM.CL_USER_NAME_ID, role: BB.RoleTypes.Bot };
                        botActivity.channelData = channelData;
                    }
                    if (botActivity) {
                        activities.push(botActivity);
                    }
                }
            }
            let memories = yield memory.BotMemory.DumpMemory();
            let hasRounds = trainDialog.rounds.length > 0;
            let hasScorerRound = (hasRounds && trainDialog.rounds[trainDialog.rounds.length - 1].scorerSteps.length > 0);
            let dialogMode = (isLastActionTerminal && hasScorerRound) || !hasRounds ? CLM.DialogMode.Wait : CLM.DialogMode.Scorer;
            // Make errors unique using Set operator 
            replayErrors = [...new Set(replayErrors)];
            let teachWithHistory = {
                teach: undefined,
                scoreInput: undefined,
                scoreResponse: undefined,
                history: activities,
                memories: memories,
                prevMemories: prevMemories,
                dialogMode: dialogMode,
                replayErrors: replayErrors
            };
            return teachWithHistory;
        });
    }
    // Generate a card to show for an API action w/o output
    APICard(apiAction) {
        let card = {
            type: "AdaptiveCard",
            version: "1.0",
            body: [
                {
                    type: "TextBlock",
                    text: `API Call: *${apiAction.name}*`
                }
            ]
        };
        const attachment = BB.CardFactory.adaptiveCard(card);
        const message = BB.MessageFactory.attachment(attachment);
        return message;
    }
}
// Lookup table for incoming calls from UI
CLRunner.Runners = {};
exports.CLRunner = CLRunner;
//# sourceMappingURL=CLRunner.js.map