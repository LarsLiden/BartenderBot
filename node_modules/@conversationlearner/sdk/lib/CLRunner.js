"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const BB = require("botbuilder");
const CLMemory_1 = require("./CLMemory");
const CLDebug_1 = require("./CLDebug");
const TemplateProvider_1 = require("./TemplateProvider");
const CLM = require("@conversationlearner/models");
const ClientMemoryManager_1 = require("./Memory/ClientMemoryManager");
const Utils_1 = require("./Utils");
const ConversationLearner_1 = require("./ConversationLearner");
const InputQueue_1 = require("./Memory/InputQueue");
const util = require("util");
var SessionStartFlags;
(function (SessionStartFlags) {
    SessionStartFlags[SessionStartFlags["NONE"] = 0] = "NONE";
    /* Start a teaching session */
    SessionStartFlags[SessionStartFlags["IN_TEACH"] = 1] = "IN_TEACH";
    /* Session is an edit and continue with existing turns */
    SessionStartFlags[SessionStartFlags["IS_EDIT_CONTINUE"] = 2] = "IS_EDIT_CONTINUE";
    /* Session created by manual timeout by user in UI */
    SessionStartFlags[SessionStartFlags["IS_MANUAL_TIMEOUT"] = 4] = "IS_MANUAL_TIMEOUT";
})(SessionStartFlags = exports.SessionStartFlags || (exports.SessionStartFlags = {}));
// tslint:disable-next-line:no-empty
exports.defaultLogicCallback = () => tslib_1.__awaiter(this, void 0, void 0, function* () { });
exports.defaultRenderCallback = (x) => tslib_1.__awaiter(this, void 0, void 0, function* () { return x; });
var ActionInputType;
(function (ActionInputType) {
    ActionInputType[ActionInputType["LOGIC_ONLY"] = 0] = "LOGIC_ONLY";
    ActionInputType[ActionInputType["RENDER_ONLY"] = 1] = "RENDER_ONLY";
    ActionInputType[ActionInputType["LOGIC_AND_RENDER"] = 2] = "LOGIC_AND_RENDER";
})(ActionInputType || (ActionInputType = {}));
class CLRunner {
    constructor(configModelId, maxTimeout, client) {
        /* Mapping between user defined API names and functions */
        this.callbacks = {};
        this.configModelId = configModelId;
        this.maxTimeout = maxTimeout;
        this.clClient = client;
    }
    static Create(configModelId, maxTimeout, client) {
        // Ok to not provide modelId when just running in training UI.
        // If not, Use UI_RUNNER_APPID const as lookup value
        let newRunner = new CLRunner(configModelId, maxTimeout, client);
        CLRunner.Runners[configModelId || Utils_1.UI_RUNNER_APPID] = newRunner;
        // Bot can define multiple CLs.  Always run UI on first CL defined in the bot
        if (!CLRunner.UIRunner) {
            CLRunner.UIRunner = newRunner;
        }
        return newRunner;
    }
    // Get CLRunner for the UI
    static GetRunnerForUI(appId) {
        // Runner with the appId may not exist if running training UI, if so use the UI Runner
        if (!appId || !CLRunner.Runners[appId]) {
            if (CLRunner.UIRunner) {
                return CLRunner.UIRunner;
            }
            else {
                throw new Error(`Not in UI and requested CLRunner that doesn't exist: ${appId}`);
            }
        }
        return CLRunner.Runners[appId];
    }
    onTurn(turnContext, next) {
        return this.recognize(turnContext, true)
            .then(next);
    }
    recognize(turnContext, force) {
        // Add input to queue
        return this.AddInput(turnContext).then(res => {
            return res;
        });
    }
    InTrainingUI(turnContext) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (turnContext.activity.from && turnContext.activity.from.name === Utils_1.CL_DEVELOPER) {
                let clMemory = CLMemory_1.CLMemory.GetMemory(turnContext.activity.from.id);
                let app = yield clMemory.BotState.GetApp();
                // If no app selected in UI or no app set in config, or they don't match return true
                if (!app || !this.configModelId || app.appId !== this.configModelId) {
                    return true;
                }
            }
            return false;
        });
    }
    // Allows Bot developer to start a new Session with initial parameters (never in Teach)
    BotStartSession(turnContext) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Set adapter / conversation reference even if from field not set
            let conversationReference = BB.TurnContext.getConversationReference(turnContext.activity);
            this.SetAdapter(turnContext.adapter, conversationReference);
            const activity = turnContext.activity;
            if (activity.from === undefined || activity.id == undefined) {
                return;
            }
            try {
                let app = yield this.GetRunningApp(activity.from.id, false);
                let clMemory = yield CLMemory_1.CLMemory.InitMemory(activity.from, conversationReference);
                if (app) {
                    let packageId = (app.livePackageId || app.devPackageId);
                    if (packageId) {
                        const sessionCreateParams = {
                            saveToLog: app.metadata.isLoggingOn !== false,
                            packageId: packageId,
                            initialFilledEntities: []
                        };
                        yield this.StartSessionAsync(clMemory, activity.conversation.id, app.appId, SessionStartFlags.NONE, sessionCreateParams);
                    }
                }
            }
            catch (error) {
                CLDebug_1.CLDebug.Error(error);
            }
        });
    }
    SetAdapter(adapter, conversationReference) {
        this.adapter = adapter;
        CLDebug_1.CLDebug.InitLogger(adapter, conversationReference);
    }
    // Add input to queue.  Allows CL to handle out-of-order messages
    AddInput(turnContext) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Set adapter / conversation reference even if from field not set
            let conversationReference = BB.TurnContext.getConversationReference(turnContext.activity);
            this.SetAdapter(turnContext.adapter, conversationReference);
            // ConversationUpdate messages are not processed by ConversationLearner
            // They should be handled in the general bot code
            if (turnContext.activity.type == "conversationUpdate") {
                CLDebug_1.CLDebug.Verbose(`Ignoring Conversation update...  +${JSON.stringify(turnContext.activity.membersAdded)} -${JSON.stringify(turnContext.activity.membersRemoved)}`);
                return null;
            }
            if (turnContext.activity.from === undefined || turnContext.activity.id == undefined) {
                return null;
            }
            let clMemory = yield CLMemory_1.CLMemory.InitMemory(turnContext.activity.from, conversationReference);
            let botState = clMemory.BotState;
            // If I'm in teach mode process message right away
            let inTeach = yield botState.GetInTeach();
            if (inTeach) {
                return yield this.ProcessInput(turnContext.activity, conversationReference);
            }
            // Otherwise I have to queue up messages as user may input them faster than bot responds
            else {
                let addInputPromise = util.promisify(InputQueue_1.InputQueue.AddInput);
                let isReady = yield addInputPromise(botState, turnContext.activity, conversationReference);
                if (isReady) {
                    let intents = yield this.ProcessInput(turnContext.activity, conversationReference);
                    return intents;
                }
                // Message has expired
                return null;
            }
        });
    }
    StartSessionAsync(clMemory, conversationId, appId, sessionStartFlags, createParams) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const inTeach = ((sessionStartFlags & SessionStartFlags.IN_TEACH) > 0);
            let entityList = yield this.clClient.GetEntities(appId);
            // If not continuing an edited session, call endSession
            if (!(sessionStartFlags && SessionStartFlags.IS_EDIT_CONTINUE)) {
                // Default callback will clear the bot memory.
                // END_SESSION action was never triggered, so SessionEndState.OPEN
                yield this.CheckSessionEndCallback(clMemory, entityList.entities, CLM.SessionEndState.OPEN);
                // Clear memory after SessionEndCallback
                yield clMemory.BotMemory.ClearAsync();
            }
            //  check that this works = should it be inside edit continue above
            // Check if StartSession call is required
            yield this.CheckSessionStartCallback(clMemory, entityList.entities);
            let startSessionEntities = yield clMemory.BotMemory.FilledEntitiesAsync();
            startSessionEntities = [...createParams.initialFilledEntities || [], ...startSessionEntities];
            const filledEntityMap = CLM.FilledEntityMap.FromFilledEntities(startSessionEntities, entityList.entities);
            clMemory.BotMemory.RestoreFromMapAsync(filledEntityMap);
            // Start the new session
            let sessionId;
            let logDialogId;
            let startResponse;
            if (inTeach) {
                const teachResponse = yield this.clClient.StartTeach(appId, createParams);
                startResponse = CLM.ModelUtils.ToTeach(teachResponse);
                sessionId = teachResponse.teachId;
                logDialogId = null;
            }
            else {
                startResponse = yield this.clClient.StartSession(appId, createParams);
                sessionId = startResponse.sessionId;
                logDialogId = startResponse.logDialogId;
            }
            // Initizize Bot State
            yield clMemory.BotState.InitSessionAsync(sessionId, logDialogId, conversationId, sessionStartFlags);
            CLDebug_1.CLDebug.Verbose(`Started Session: ${sessionId} - ${conversationId}`);
            return startResponse;
        });
    }
    // Get the currently running app
    GetRunningApp(key, inEditingUI) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let clMemory = CLMemory_1.CLMemory.GetMemory(key);
            let app = yield clMemory.BotState.GetApp();
            if (app) {
                // If I'm not in the editing UI, always use app specified by options
                if (!inEditingUI && this.configModelId && this.configModelId != app.appId) {
                    // Use config value
                    CLDebug_1.CLDebug.Log(`Switching to app specified in config: ${this.configModelId}`);
                    app = yield this.clClient.GetApp(this.configModelId);
                    yield clMemory.SetAppAsync(app);
                }
            }
            // If I don't have an app, attempt to use one set in config
            else if (this.configModelId) {
                CLDebug_1.CLDebug.Log(`Selecting app specified in config: ${this.configModelId}`);
                app = yield this.clClient.GetApp(this.configModelId);
                yield clMemory.SetAppAsync(app);
            }
            return app;
        });
    }
    // End a teach or log session
    // originalSessionId is sent when session terminated from EndSession action or expiration
    EndSessionAsync(key, sessionEndState, originalSessionId = null, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let memory = CLMemory_1.CLMemory.GetMemory(key);
            let app = yield memory.BotState.GetApp();
            if (app) {
                let entityList = yield this.clClient.GetEntities(app.appId);
                // Default callback will clear the bot memory
                yield this.CheckSessionEndCallback(memory, entityList.entities, sessionEndState, data);
                yield memory.BotState.EndSessionAsync(originalSessionId);
            }
        });
    }
    // Process user input
    ProcessInput(activity, conversationReference) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let errComponent = 'ProcessInput';
            // Validate request
            if (!activity.from || !activity.from.id) {
                throw new Error(`Attempted to get current session for user, but user was not defined on bot request.`);
            }
            try {
                let inEditingUI = conversationReference.user &&
                    conversationReference.user.name === Utils_1.CL_DEVELOPER || false;
                // Validate setup
                if (!inEditingUI && !this.configModelId) {
                    let msg = 'Must specify modelId in ConversationLearner constructor when not running bot in Editing UI\n\n';
                    CLDebug_1.CLDebug.Error(msg);
                    return null;
                }
                if (!ConversationLearner_1.ConversationLearner.options || !ConversationLearner_1.ConversationLearner.options.LUIS_AUTHORING_KEY) {
                    let msg = 'Options must specify luisAuthoringKey.  Set the LUIS_AUTHORING_KEY.\n\n';
                    CLDebug_1.CLDebug.Error(msg);
                    return null;
                }
                let app = yield this.GetRunningApp(activity.from.id, inEditingUI);
                let clMemory = yield CLMemory_1.CLMemory.InitMemory(activity.from, conversationReference);
                let inTeach = yield clMemory.BotState.GetInTeach();
                if (!app) {
                    let error = "ERROR: AppId not specified.  When running in a channel (i.e. Skype) or the Bot Framework Emulator, CONVERSATION_LEARNER_MODEL_ID must be specified in your Bot's .env file or Application Settings on the server";
                    yield this.SendMessage(clMemory, error, activity.id);
                    return null;
                }
                let sessionId = yield clMemory.BotState.GetSessionIdAndSetConversationId(activity.conversation.id);
                // If I'm not in teach mode and have a session
                if (!inTeach && sessionId) {
                    const currentTicks = new Date().getTime();
                    let lastActive = yield clMemory.BotState.GetLastActive();
                    let passedTicks = currentTicks - lastActive;
                    if (passedTicks > this.maxTimeout) {
                        // End the current session, clear the memory
                        yield this.clClient.EndSession(app.appId, sessionId);
                        // Send original session Id. Used for continuing sessions
                        yield this.EndSessionAsync(activity.from.id, CLM.SessionEndState.OPEN, sessionId);
                        // If I'm not in the UI, reload the App to get any changes (live package version may have been updated)
                        if (!inEditingUI) {
                            if (!this.configModelId) {
                                let error = "ERROR: ModelId not specified.  When running in a channel (i.e. Skype) or the Bot Framework Emulator, CONVERSATION_LEARNER_MODEL_ID must be specified in your Bot's .env file or Application Settings on the server";
                                yield this.SendMessage(clMemory, error, activity.id);
                                return null;
                            }
                            app = yield this.clClient.GetApp(this.configModelId);
                            yield clMemory.SetAppAsync(app);
                            if (!app) {
                                let error = "ERROR: Failed to find Model specified by CONVERSATION_LEARNER_MODEL_ID";
                                yield this.SendMessage(clMemory, error, activity.id);
                                return null;
                            }
                        }
                        let conversationId = yield clMemory.BotState.GetConversationId();
                        // Start a new session
                        const sessionCreateParams = {
                            saveToLog: app.metadata.isLoggingOn,
                            initialFilledEntities: []
                        };
                        let session = yield this.StartSessionAsync(clMemory, conversationId, app.appId, SessionStartFlags.IS_MANUAL_TIMEOUT, sessionCreateParams);
                        sessionId = session.sessionId;
                    }
                    // Otherwise update last access time
                    else {
                        yield clMemory.BotState.SetLastActive(currentTicks);
                    }
                }
                // Handle any other non-message input
                if (activity.type !== "message") {
                    yield InputQueue_1.InputQueue.MessageHandled(clMemory.BotState, activity.id);
                    return null;
                }
                // PackageId: Use live package id if not in editing UI, default to devPackage if no active package set
                let packageId = (inEditingUI ? yield clMemory.BotState.GetEditingPackageForApp(app.appId) : app.livePackageId) || app.devPackageId;
                if (!packageId) {
                    yield this.SendMessage(clMemory, "ERROR: No PackageId has been set", activity.id);
                    return null;
                }
                // If no session for this conversation, create a new one
                if (!sessionId) {
                    const sessionCreateParams = {
                        saveToLog: app.metadata.isLoggingOn !== false,
                        packageId: packageId,
                        initialFilledEntities: []
                    };
                    let session = yield this.StartSessionAsync(clMemory, activity.conversation.id, app.appId, SessionStartFlags.NONE, sessionCreateParams);
                    sessionId = session.sessionId;
                }
                // Process any form data
                let buttonResponse = yield this.ProcessFormData(activity, clMemory, app.appId);
                // Teach inputs are handled via API calls from the Conversation Learner UI
                if (!inTeach) {
                    let entities = [];
                    errComponent = 'SessionExtract';
                    let userInput = { text: buttonResponse || activity.text || '  ' };
                    let extractResponse = yield this.clClient.SessionExtract(app.appId, sessionId, userInput);
                    entities = extractResponse.definitions.entities;
                    errComponent = 'ProcessExtraction';
                    const scoredAction = yield this.Score(app.appId, sessionId, clMemory, extractResponse.text, extractResponse.predictedEntities, entities, inTeach);
                    return {
                        scoredAction: scoredAction,
                        clEntities: entities,
                        memory: clMemory,
                        inTeach: false,
                        activity: activity
                    };
                }
                return null;
            }
            catch (error) {
                // Try to end the session, so use can potentially recover
                try {
                    yield this.EndSessionAsync(activity.from.id, CLM.SessionEndState.OPEN);
                }
                catch (_a) {
                    CLDebug_1.CLDebug.Log(`Failed to End Session`);
                }
                CLDebug_1.CLDebug.Error(error, errComponent);
                return null;
            }
        });
    }
    ProcessFormData(request, clMemory, appId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const data = request.value;
            if (data) {
                // Get list of all entities
                let entityList = yield this.clClient.GetEntities(appId);
                // For each form entry
                for (let entityName of Object.keys(data)) {
                    // Reserved parameter
                    if (entityName == 'submit') {
                        continue;
                    }
                    // Find the entity
                    let entity = entityList.entities.find((e) => e.entityName == entityName);
                    if (!entity) {
                        CLDebug_1.CLDebug.Error(`Form - Can't find Entity named: ${entityName}`);
                        return null;
                    }
                    // Set it
                    yield clMemory.BotMemory.RememberEntity(entity.entityName, entity.entityId, data[entityName], entity.isMultivalue);
                }
                // If submit type return as a response
                if (data['submit']) {
                    return data['submit'];
                }
                else {
                    CLDebug_1.CLDebug.Error(`Adaptive Card has no Submit data`);
                    return null;
                }
            }
            return null;
        });
    }
    Score(appId, sessionId, memory, text, predictedEntities, allEntities, inTeach) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Call LUIS callback
            let scoreInput = yield this.CallEntityDetectionCallback(text, predictedEntities, memory, allEntities);
            // Call the scorer
            let scoreResponse = null;
            if (inTeach) {
                scoreResponse = yield this.clClient.TeachScore(appId, sessionId, scoreInput);
            }
            else {
                scoreResponse = yield this.clClient.SessionScore(appId, sessionId, scoreInput);
            }
            // Get best action
            let bestAction = scoreResponse.scoredActions[0];
            // Return the action
            return bestAction;
        });
    }
    AddCallback(callback) {
        if (typeof callback.name !== "string" || callback.name.trim().length === 0) {
            throw new Error(`You attempted to add callback but did not provide a valid name. Name must be non-empty string.`);
        }
        if (!callback.logic && !callback.render) {
            throw new Error(`You attempted to add callback by name: ${callback.name} but did not provide a logic or render function. You must provide at least one of them.`);
        }
        if (!callback.logic) {
            callback.logic = exports.defaultLogicCallback;
        }
        if (!callback.render) {
            callback.render = exports.defaultRenderCallback;
        }
        this.callbacks[callback.name] = Object.assign({}, callback, { logicArguments: this.GetArguments(callback.logic, 1), renderArguments: this.GetArguments(callback.render, 2) });
    }
    GetArguments(func, skip = 0) {
        const STRIP_COMMENTS = /(\/\/.*$)|(\/\*[\s\S]*?\*\/)|(\s*=[^,\)]*(('(?:\\'|[^'\r\n])*')|("(?:\\"|[^"\r\n])*"))|(\s*=[^,\)]*))/gm;
        const ARGUMENT_NAMES = /([^\s,]+)/g;
        const fnStr = func.toString().replace(STRIP_COMMENTS, '');
        const argumentNames = fnStr.slice(fnStr.indexOf('(') + 1, fnStr.indexOf(')')).match(ARGUMENT_NAMES) || [];
        return argumentNames.filter((_, i) => i >= skip);
    }
    ProcessPredictedEntities(text, memory, predictedEntities, allEntities) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Update entities in my memory
            for (let predictedEntity of predictedEntities) {
                let entity = allEntities.find(e => e.entityId == predictedEntity.entityId);
                if (!entity) {
                    CLDebug_1.CLDebug.Error(`Could not find entity by id: ${predictedEntity.entityId}`);
                    return;
                }
                // If negative entity will have a positive counter entity
                if (entity.positiveId) {
                    yield memory.ForgetEntity(entity.entityName, predictedEntity.entityText, entity.isMultivalue);
                }
                else {
                    yield memory.RememberEntity(entity.entityName, entity.entityId, predictedEntity.entityText, entity.isMultivalue, predictedEntity.builtinType, predictedEntity.resolution);
                }
            }
        });
    }
    CallEntityDetectionCallback(text, predictedEntities, clMemory, allEntities) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Entities before processing
            let prevMemories = new CLM.FilledEntityMap(yield clMemory.BotMemory.FilledEntityMap());
            // Update memory with predicted entities
            yield this.ProcessPredictedEntities(text, clMemory.BotMemory, predictedEntities, allEntities);
            let memoryManager = yield this.CreateMemoryManagerAsync(clMemory, allEntities, prevMemories);
            // If bot has callback, call it
            if (this.entityDetectionCallback) {
                try {
                    yield this.entityDetectionCallback(text, memoryManager);
                    // Update Memory
                    yield clMemory.BotMemory.RestoreFromMemoryManagerAsync(memoryManager);
                }
                catch (err) {
                    yield this.SendMessage(clMemory, "Exception hit in Bot's EntityDetectionCallback");
                    let errMsg = CLDebug_1.CLDebug.Error(err);
                    this.SendMessage(clMemory, errMsg);
                }
            }
            // Get entities from my memory
            const filledEntities = yield clMemory.BotMemory.FilledEntitiesAsync();
            let scoreInput = {
                filledEntities,
                context: {},
                maskedActions: []
            };
            return scoreInput;
        });
    }
    CreateMemoryManagerAsync(clMemory, allEntities, prevMemories) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let sessionInfo = yield clMemory.BotState.SessionInfoAsync();
            let curMemories = new CLM.FilledEntityMap(yield clMemory.BotMemory.FilledEntityMap());
            if (!prevMemories) {
                prevMemories = curMemories;
            }
            return new ClientMemoryManager_1.ClientMemoryManager(prevMemories, curMemories, allEntities, sessionInfo);
        });
    }
    // Call session start callback, set memory and return list of filled entities coming from callback
    CheckSessionStartCallback(clMemory, entities) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // If bot has callback, call it
            if (this.onSessionStartCallback && this.adapter) {
                let memoryManager = yield this.CreateMemoryManagerAsync(clMemory, entities);
                // Get conversation ref, so I can generate context and send it back to bot dev
                let conversationReference = yield clMemory.BotState.GetConversationReverence();
                if (!conversationReference) {
                    CLDebug_1.CLDebug.Error('Missing ConversationReference');
                    return;
                }
                yield this.adapter.continueConversation(conversationReference, (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    if (this.onSessionStartCallback) {
                        try {
                            yield this.onSessionStartCallback(context, memoryManager);
                            yield clMemory.BotMemory.RestoreFromMemoryManagerAsync(memoryManager);
                        }
                        catch (err) {
                            yield this.SendMessage(clMemory, "Exception hit in Bot's OnSessionStartCallback");
                            let errMsg = CLDebug_1.CLDebug.Error(err);
                            this.SendMessage(clMemory, errMsg);
                        }
                    }
                }));
            }
        });
    }
    CheckSessionEndCallback(clMemory, entities, sessionEndState, data) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // If onEndSession hasn't been called yet, call it
            let needEndSession = yield clMemory.BotState.GetNeedSessionEndCall();
            if (needEndSession) {
                // If bot has callback, call it to determine which entities to clear / edit
                if (this.onSessionEndCallback && this.adapter) {
                    let memoryManager = yield this.CreateMemoryManagerAsync(clMemory, entities);
                    // Get conversation ref, so I can generate context and send it back to bot dev
                    let conversationReference = yield clMemory.BotState.GetConversationReverence();
                    if (!conversationReference) {
                        CLDebug_1.CLDebug.Error('Missing ConversationReference');
                        return;
                    }
                    yield this.adapter.continueConversation(conversationReference, (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                        try {
                            let saveEntities = this.onSessionEndCallback
                                ? yield this.onSessionEndCallback(context, memoryManager, sessionEndState, data)
                                : undefined;
                            yield clMemory.BotMemory.ClearAsync(saveEntities);
                        }
                        catch (err) {
                            yield this.SendMessage(clMemory, "Exception hit in Bot's OnSessionEndCallback");
                            let errMsg = CLDebug_1.CLDebug.Error(err);
                            this.SendMessage(clMemory, errMsg);
                        }
                    }));
                }
                // Otherwise just clear the memory
                else {
                    yield clMemory.BotMemory.ClearAsync();
                }
                yield clMemory.BotState.SetNeedSessionEndCall(false);
            }
        });
    }
    RenderTemplateAsync(conversationReference, clRecognizeResult, channelData) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Get filled entities from memory
            let filledEntityMap = yield clRecognizeResult.memory.BotMemory.FilledEntityMap();
            filledEntityMap = Utils_1.addEntitiesById(filledEntityMap);
            // If the action was terminal, free up the mutex allowing queued messages to be processed
            // Activity won't be present if running in training as messages aren't queued
            if (clRecognizeResult.scoredAction.isTerminal && clRecognizeResult.activity) {
                yield InputQueue_1.InputQueue.MessageHandled(clRecognizeResult.memory.BotState, clRecognizeResult.activity.id);
            }
            if (!conversationReference.conversation) {
                throw new Error(`ConversationReference contains no conversation`);
            }
            let actionResult;
            const inTeach = channelData !== null;
            switch (clRecognizeResult.scoredAction.actionType) {
                case CLM.ActionTypes.TEXT: {
                    // This is hack to allow ScoredAction to be accepted as ActionBase
                    // TODO: Remove extra properties from ScoredAction so it only had actionId and up service to return actions definitions of scored/unscored actions
                    // so UI can link the two together instead of having "partial" actions being incorrectly treated as full actions
                    const textAction = new CLM.TextAction(clRecognizeResult.scoredAction);
                    const response = yield this.TakeTextAction(textAction, filledEntityMap);
                    actionResult = {
                        logicResult: undefined,
                        response
                    };
                    break;
                }
                case CLM.ActionTypes.API_LOCAL: {
                    const apiAction = new CLM.ApiAction(clRecognizeResult.scoredAction);
                    actionResult = yield this.TakeAPIAction(apiAction, filledEntityMap, clRecognizeResult.memory, clRecognizeResult.clEntities, inTeach, {
                        type: ActionInputType.LOGIC_AND_RENDER
                    });
                    break;
                }
                case CLM.ActionTypes.CARD: {
                    const cardAction = new CLM.CardAction(clRecognizeResult.scoredAction);
                    const response = yield this.TakeCardAction(cardAction, filledEntityMap);
                    actionResult = {
                        logicResult: undefined,
                        response
                    };
                    break;
                }
                case CLM.ActionTypes.END_SESSION: {
                    const sessionAction = new CLM.SessionAction(clRecognizeResult.scoredAction);
                    let sessionInfo = yield clRecognizeResult.memory.BotState.SessionInfoAsync();
                    let sessionId = yield clRecognizeResult.memory.BotState.GetSessionIdAndSetConversationId(conversationReference.conversation.id);
                    const response = yield this.TakeSessionAction(sessionAction, filledEntityMap, inTeach, sessionInfo.userId, sessionId);
                    actionResult = {
                        logicResult: undefined,
                        response
                    };
                    break;
                }
                default:
                    throw new Error(`Could not find matching renderer for action type: ${clRecognizeResult.scoredAction.actionType}`);
            }
            // Convert string actions to activities
            if (typeof actionResult.response === 'string') {
                actionResult.response = BB.MessageFactory.text(actionResult.response);
            }
            if (actionResult.response && channelData) {
                actionResult.response.channelData = channelData;
            }
            // If action wasn't terminal loop through Conversation Learner again after a short delay
            if (!clRecognizeResult.scoredAction.isTerminal) {
                setTimeout(() => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    let app = yield clRecognizeResult.memory.BotState.GetApp();
                    if (!app) {
                        throw new Error(`Attempted to get current app before app was set.`);
                    }
                    if (!conversationReference.conversation) {
                        throw new Error(`Attempted to get session by conversation id, but user was not defined on current conversation`);
                    }
                    let sessionId = yield clRecognizeResult.memory.BotState.GetSessionIdAndSetConversationId(conversationReference.conversation.id);
                    if (!sessionId) {
                        throw new Error(`Attempted to get session by conversation id: ${conversationReference.conversation.id} but session was not found`);
                    }
                    // If not inTeach, send message to user
                    if (!clRecognizeResult.inTeach) {
                        let bestAction = yield this.Score(app.appId, sessionId, clRecognizeResult.memory, '', [], clRecognizeResult.clEntities, clRecognizeResult.inTeach);
                        clRecognizeResult.scoredAction = bestAction;
                        // LARS - need to increment scorere step in channel data
                        actionResult = yield this.RenderTemplateAsync(conversationReference, clRecognizeResult, channelData);
                        if (actionResult.response != null) {
                            this.SendMessage(clRecognizeResult.memory, actionResult.response);
                        }
                    }
                }), 100);
            }
            return actionResult;
        });
    }
    SendIntent(intent, channelData = null) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let conversationReference = yield intent.memory.BotState.GetConversationReverence();
            if (!conversationReference) {
                CLDebug_1.CLDebug.Error('Missing ConversationReference');
                return;
            }
            if (!this.adapter) {
                CLDebug_1.CLDebug.Error('Missing Adapter');
                return;
            }
            const actionResult = yield this.RenderTemplateAsync(conversationReference, intent, channelData);
            if (actionResult.response != null) {
                yield this.adapter.continueConversation(conversationReference, (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                    // Need to repeat null check as compiler is catching one above for explicit null
                    if (actionResult.response != null) {
                        yield context.sendActivity(actionResult.response);
                    }
                }));
            }
            return actionResult;
        });
    }
    SendMessage(memory, message, incomingActivityId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // If requested, pop incoming activity from message queue
            if (incomingActivityId) {
                yield InputQueue_1.InputQueue.MessageHandled(memory.BotState, incomingActivityId);
            }
            let conversationReference = yield memory.BotState.GetConversationReverence();
            if (!conversationReference) {
                CLDebug_1.CLDebug.Error('Missing ConversationReference');
                return;
            }
            if (!this.adapter) {
                CLDebug_1.CLDebug.Error(`Attempted to send message before adapter was assigned`);
                return;
            }
            yield this.adapter.continueConversation(conversationReference, (context) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                yield context.sendActivity(message);
            }));
        });
    }
    // TODO: This issue arises because we only save non-null non-empty argument values on the actions
    // which means callback may accept more arguments than is actually available on the action.arguments
    // To me, it seems it would make more sense to always have these be same length, but perhaps there is
    // dependency on action not being defined somewhere else in the application like ActionCreatorEditor
    GetRenderedArguments(fnArgs, actionArgs, filledEntityMap) {
        const missingEntityNames = [];
        const renderedArgumentValues = fnArgs.map(param => {
            const argument = actionArgs.find(arg => arg.parameter === param);
            if (!argument) {
                return '';
            }
            try {
                return argument.renderValue(CLM.getEntityDisplayValueMap(filledEntityMap));
            }
            catch (error) {
                missingEntityNames.push(param);
                return '';
            }
        }, missingEntityNames);
        if (missingEntityNames.length > 0) {
            throw new Error(`Missing Entity value(s) for ${missingEntityNames.join(', ')}`);
        }
        return renderedArgumentValues;
    }
    TakeAPIAction(apiAction, filledEntityMap, clMemory, allEntities, inTeach, actionInput) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Extract API name and args
            const callback = this.callbacks[apiAction.name];
            if (!callback) {
                return {
                    logicResult: undefined,
                    response: CLDebug_1.CLDebug.Error(`API callback with name "${apiAction.name}" is not defined`)
                };
            }
            try {
                try {
                    // Invoke Logic part of callback
                    const renderedLogicArgumentValues = this.GetRenderedArguments(callback.logicArguments, apiAction.logicArguments, filledEntityMap);
                    const memoryManager = yield this.CreateMemoryManagerAsync(clMemory, allEntities);
                    // If we're only doing the render part, used stored input value
                    // This happens when replaying dialog to recreated action outputs
                    let logicResult;
                    if (actionInput.type === ActionInputType.RENDER_ONLY) {
                        const value = actionInput.value;
                        logicResult = value ? JSON.parse(value) : undefined;
                    }
                    else {
                        logicResult = yield callback.logic(memoryManager, ...renderedLogicArgumentValues);
                    }
                    yield clMemory.BotMemory.RestoreFromMemoryManagerAsync(memoryManager);
                    // Render the action unless only doing logic part
                    if (actionInput.type === ActionInputType.LOGIC_ONLY) {
                        return {
                            logicResult,
                            response: null
                        };
                    }
                    else {
                        // Invoke Render part of callback
                        const renderedRenderArgumentValues = this.GetRenderedArguments(callback.renderArguments, apiAction.renderArguments, filledEntityMap);
                        let response = yield callback.render(logicResult, memoryManager.AsReadOnly(), ...renderedRenderArgumentValues);
                        // If response is empty, but we're in teach session return a placeholder card in WebChat so they can click it to edit
                        // Otherwise return the response as is.
                        if (!response && inTeach) {
                            response = this.APICard(callback);
                        }
                        return {
                            logicResult,
                            response
                        };
                    }
                }
                catch (err) {
                    yield this.SendMessage(clMemory, `Exception hit in Bot's API Callback: '${apiAction.name}'`);
                    return {
                        logicResult: undefined,
                        response: CLDebug_1.CLDebug.Error(err)
                    };
                }
            }
            catch (err) {
                return {
                    logicResult: undefined,
                    response: CLDebug_1.CLDebug.Error(err)
                };
            }
        });
    }
    TakeTextAction(textAction, filledEntityMap) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return Promise.resolve(textAction.renderValue(CLM.getEntityDisplayValueMap(filledEntityMap)));
        });
    }
    TakeCardAction(cardAction, filledEntityMap) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                const entityDisplayValues = CLM.getEntityDisplayValueMap(filledEntityMap);
                const renderedArguments = cardAction.renderArguments(entityDisplayValues);
                const missingEntities = renderedArguments.filter(ra => ra.value === null);
                if (missingEntities.length > 0) {
                    return `ERROR: Missing Entity value(s) for ${missingEntities.map(me => me.parameter).join(', ')}`;
                }
                const form = yield TemplateProvider_1.TemplateProvider.RenderTemplate(cardAction.templateName, renderedArguments);
                if (form == null) {
                    return CLDebug_1.CLDebug.Error(`Missing Template: ${cardAction.templateName}`);
                }
                const attachment = BB.CardFactory.adaptiveCard(form);
                const message = BB.MessageFactory.attachment(attachment);
                message.text = undefined;
                return message;
            }
            catch (error) {
                let msg = CLDebug_1.CLDebug.Error(error, 'Failed to Render Template');
                return msg;
            }
        });
    }
    TakeSessionAction(sessionAction, filledEntityMap, inTeach, userId, sessionId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Get any context from the action
            let content = sessionAction.renderValue(CLM.getEntityDisplayValueMap(filledEntityMap));
            // Send original session Id. Used for continuing sessions
            yield this.EndSessionAsync(userId, CLM.SessionEndState.COMPLETED, sessionId, content);
            // If inTeach, show something to user in WebChat so they can edit
            if (inTeach) {
                let payload = sessionAction.renderValue(CLM.getEntityDisplayValueMap(filledEntityMap));
                let card = {
                    type: "AdaptiveCard",
                    version: "1.0",
                    body: [
                        {
                            type: "TextBlock",
                            text: `EndSession: *${payload}*`
                        }
                    ]
                };
                const attachment = BB.CardFactory.adaptiveCard(card);
                const message = BB.MessageFactory.attachment(attachment);
                return message;
            }
            return null;
        });
    }
    // Returns true if Action is available given Entities in Memory
    isActionAvailable(action, filledEntities) {
        for (let entityId of action.requiredEntities) {
            let found = filledEntities.find(e => e.entityId == entityId);
            if (!found) {
                return false;
            }
        }
        for (let entityId of action.negativeEntities) {
            let found = filledEntities.find(e => e.entityId == entityId);
            if (found) {
                return false;
            }
        }
        return true;
    }
    /** Convert list of filled entities into a filled entity map lookup table */
    CreateFilledEntityMap(filledEntities, entityList) {
        let filledEntityMap = new CLM.FilledEntityMap();
        for (let filledEntity of filledEntities) {
            let entity = entityList.entities.find(e => e.entityId == filledEntity.entityId);
            if (entity) {
                filledEntityMap.map[entity.entityName] = filledEntity;
                filledEntityMap.map[entity.entityId] = filledEntity;
            }
        }
        return filledEntityMap;
    }
    /**
     * Identify any validation issues
     * Missing Entities
     * Missing Actions
     * Unavailable Actions
     */
    DialogValidationErrors(trainDialog, entities, actions) {
        let validationErrors = [];
        for (let round of trainDialog.rounds) {
            let userText = round.extractorStep.textVariations[0].text;
            let filledEntities = round.scorerSteps[0] && round.scorerSteps[0].input ? round.scorerSteps[0].input.filledEntities : [];
            // Check that entities exist
            for (let filledEntity of filledEntities) {
                if (!entities.find(e => e.entityId == filledEntity.entityId)) {
                    validationErrors.push(`Missing Entity for "${CLM.filledEntityValueAsString(filledEntity)}"`);
                }
            }
            for (let scorerStep of round.scorerSteps) {
                let labelAction = scorerStep.labelAction;
                // Check that action exists
                let selectedAction = actions.find(a => a.actionId == labelAction);
                if (!selectedAction) {
                    validationErrors.push(`Missing Action response for "${userText}"`);
                }
                else {
                    // Check action availability
                    if (!this.isActionAvailable(selectedAction, scorerStep.input.filledEntities)) {
                        validationErrors.push(`Selected Action in unavailable in response to "${userText}"`);
                    }
                }
            }
        }
        // Make errors unique using Set operator
        validationErrors = [...new Set(validationErrors)];
        return validationErrors;
    }
    /** Return a list of trainDialogs that are invalid for the given set of entities and actions */
    validateTrainDialogs(appDefinition) {
        let invalidTrainDialogIds = [];
        for (let trainDialog of appDefinition.trainDialogs) {
            // Ignore train dialogs that are already invalid
            if (!trainDialog.invalid) {
                let validationErrors = this.DialogValidationErrors(trainDialog, appDefinition.entities, appDefinition.actions);
                if (validationErrors.length > 0) {
                    invalidTrainDialogIds.push(trainDialog.trainDialogId);
                }
            }
        }
        return invalidTrainDialogIds;
    }
    /** Populate prebuilt information in predicted entities given filled entity array */
    PopulatePrebuilts(predictedEntities, filledEntities) {
        for (let pe of predictedEntities) {
            let filledEnt = filledEntities.find(fe => fe.entityId === pe.entityId);
            if (filledEnt) {
                let value = filledEnt.values.find(v => v.userText === pe.entityText);
                if (value) {
                    pe.resolution = value.resolution;
                    if (value.builtinType) {
                        pe.builtinType = value.builtinType;
                    }
                }
            }
        }
    }
    /**
     * Provide dummy data for any missing entities so they can still be rendered
     */
    PopulateMissingFilledEntities(action, filledEntityMap, allEntities) {
        // For backwards compatibiliity need to check requieredEntities too.  In new version all in requiredEntitiesFromPayload
        const allRequiredEntities = [...action.requiredEntities, ...action.requiredEntitiesFromPayload];
        let missingEntities = [];
        allRequiredEntities.forEach((entityId) => {
            let entity = allEntities.find(e => e.entityId === entityId);
            if (entity) {
                if (!filledEntityMap.map[entity.entityName]) {
                    let memoryValue = {
                        userText: `["$${entity.entityName}"]`
                    };
                    let filledEntity = {
                        entityId: entityId,
                        values: [memoryValue]
                    };
                    filledEntityMap.map[entity.entityName] = filledEntity;
                    filledEntityMap.map[entity.entityId] = filledEntity;
                    missingEntities.push(entity.entityName);
                }
                else {
                    const value = filledEntityMap.ValueAsString(entity.entityName);
                    if (value && value.startsWith(`["$`)) {
                        missingEntities.push(entity.entityName);
                    }
                }
            }
            else {
                throw new Error(`ENTITY ${entityId} DOES NOT EXIST`);
            }
        });
        return missingEntities;
    }
    /**
     * Initialize memory for replay
     */
    InitReplayMemory(clMemory, trainDialog, entities) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Reset the memory
            yield clMemory.BotMemory.ClearAsync();
            let map = CLM.FilledEntityMap.FromFilledEntities(trainDialog.initialFilledEntities || [], entities);
            yield clMemory.BotMemory.RestoreFromMapAsync(map);
        });
    }
    /**
     * Replay a TrainDialog, calling EntityDetection callback and API Logic,
     * recalculating FilledEntities along the way
     */
    ReplayTrainDialogLogic(trainDialog, clMemory, cleanse) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!trainDialog || !trainDialog.rounds) {
                return trainDialog;
            }
            // Copy train dialog
            let newTrainDialog = JSON.parse(JSON.stringify(trainDialog));
            let entities = trainDialog.definitions ? trainDialog.definitions.entities : [];
            let actions = trainDialog.definitions ? trainDialog.definitions.actions : [];
            let entityList = { entities };
            yield this.InitReplayMemory(clMemory, newTrainDialog, entities);
            for (let round of newTrainDialog.rounds) {
                // Call entity detection callback with first text Variation
                let textVariation = round.extractorStep.textVariations[0];
                let predictedEntities = CLM.ModelUtils.ToPredictedEntities(textVariation.labelEntities);
                // Call EntityDetectionCallback and populate filledEntities with the result
                let scoreInput = yield this.CallEntityDetectionCallback(textVariation.text, predictedEntities, clMemory, entities);
                // Use scorer step to populate pre-built data (when)
                if (round.scorerSteps && round.scorerSteps.length > 0) {
                    // LARS - check this - value not used?
                    this.PopulatePrebuilts(predictedEntities, scoreInput.filledEntities);
                    round.scorerSteps[0].input.filledEntities = scoreInput.filledEntities;
                    // Go through each scorer step
                    for (let [scoreIndex, scorerStep] of round.scorerSteps.entries()) {
                        let curAction = actions.filter((a) => a.actionId === scorerStep.labelAction)[0];
                        if (curAction) {
                            let filledEntityMap = yield clMemory.BotMemory.FilledEntityMap();
                            // Fill in missing entities with a warning
                            this.PopulateMissingFilledEntities(curAction, filledEntityMap, entities);
                            round.scorerSteps[scoreIndex].input.filledEntities = filledEntityMap.FilledEntities();
                            // Run logic part of APIAction to update the FilledEntities
                            if (curAction.actionType === CLM.ActionTypes.API_LOCAL) {
                                const apiAction = new CLM.ApiAction(curAction);
                                const actionInput = {
                                    type: ActionInputType.LOGIC_ONLY
                                };
                                yield this.TakeAPIAction(apiAction, filledEntityMap, clMemory, entityList.entities, true, actionInput);
                            }
                            else if (curAction.actionType === CLM.ActionTypes.END_SESSION) {
                                // LARS - todo, what is needed here
                                const sessionAction = new CLM.SessionAction(curAction);
                                let sessionInfo = yield clMemory.BotState.SessionInfoAsync();
                                yield this.TakeSessionAction(sessionAction, filledEntityMap, true, sessionInfo.userId, null);
                            }
                        }
                    }
                }
                else {
                    // Otherwise create a dummy scorer step with the filled entities
                    const scorerStep = {
                        input: {
                            filledEntities: yield clMemory.BotMemory.FilledEntitiesAsync(),
                            context: {},
                            maskedActions: []
                        },
                        labelAction: undefined,
                        logicResult: undefined,
                        scoredAction: undefined
                    };
                    if (!round.scorerSteps) {
                        round.scorerSteps = [];
                    }
                    round.scorerSteps.push(scorerStep);
                }
            }
            // When editing, may need to run Scorer or Extrator on TrainDialog with invalid rounds
            //This cleans up the TrainDialog removing bad data so the extractor can run  
            if (cleanse) {
                // Remove rounds with two user inputs in a row (they'll have a dummy scorer round)
                newTrainDialog.rounds = newTrainDialog.rounds.filter(r => {
                    return !r.scorerSteps[0] || r.scorerSteps[0].labelAction != undefined;
                });
            }
            return newTrainDialog;
        });
    }
    /**
     * Get Activities generated by trainDialog.
     * Return any errors in TrainDialog
     * NOTE: Will set bot memory to state at end of history
     */
    GetHistory(trainDialog, userName, userId, clMemory) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let entities = trainDialog.definitions ? trainDialog.definitions.entities : [];
            let actions = trainDialog.definitions ? trainDialog.definitions.actions : [];
            let entityList = { entities };
            let prevMemories = [];
            if (!trainDialog || !trainDialog.rounds) {
                return null;
            }
            yield this.InitReplayMemory(clMemory, trainDialog, entities);
            let activities = [];
            let replayError = null;
            let highlight = null;
            let replayErrors = [];
            let curAction = null;
            for (let [roundNum, round] of trainDialog.rounds.entries()) {
                let userText = round.extractorStep.textVariations[0].text;
                let filledEntities = round.scorerSteps[0] && round.scorerSteps[0].input ? round.scorerSteps[0].input.filledEntities : [];
                // VALIDATION
                highlight = null;
                replayError = null;
                // Check that entities exist
                for (let filledEntity of filledEntities) {
                    if (!entities.find(e => e.entityId == filledEntity.entityId)) {
                        highlight = "warning";
                        replayError = new CLM.ReplayErrorEntityUndefined(CLM.filledEntityValueAsString(filledEntity));
                        replayErrors.push();
                    }
                }
                // Check for double user inputs
                if (roundNum != trainDialog.rounds.length - 1 &&
                    (round.scorerSteps.length === 0 || !round.scorerSteps[0].labelAction)) {
                    highlight = "error";
                    replayError = new CLM.ReplayErrorTwoUserInputs();
                    replayErrors.push(replayError);
                }
                // Check for user input when previous action wasn't wait
                if (curAction && !curAction.isTerminal) {
                    highlight = "error";
                    replayError = new CLM.ReplayErrorInputAfterNonWait();
                    replayErrors.push(replayError);
                }
                // Generate activity
                let userActivity = CLM.ModelUtils.InputToActivity(userText, userName, userId, roundNum);
                userActivity.channelData.highlight = highlight;
                userActivity.channelData.replayError = replayError;
                activities.push(userActivity);
                // Save memory before this step (used to show changes in UI)
                prevMemories = yield clMemory.BotMemory.DumpMemory();
                // Call entity detection callback - LARS REVIEW COMMENTS
                let textVariation = round.extractorStep.textVariations[0];
                let predictedEntities = CLM.ModelUtils.ToPredictedEntities(textVariation.labelEntities);
                // Use scorer step to populate pre-built data (when)
                if (round.scorerSteps.length > 0) {
                    this.PopulatePrebuilts(predictedEntities, round.scorerSteps[0].input.filledEntities);
                }
                for (let [scoreIndex, scorerStep] of round.scorerSteps.entries()) {
                    let labelAction = scorerStep.labelAction;
                    // Scorer rounds w/o labelActions may exist to store extraction result for rendering
                    if (labelAction) {
                        let scoreFilledEntities = scorerStep.input.filledEntities;
                        // VALIDATION
                        highlight = null;
                        replayError = null;
                        // Check that action exists
                        let selectedAction = actions.find(a => a.actionId == labelAction);
                        if (!selectedAction) {
                            highlight = "error";
                            replayError = new CLM.ReplayErrorActionUndefined(userText);
                            replayErrors.push(replayError);
                        }
                        else {
                            // Check action availability
                            if (!this.isActionAvailable(selectedAction, scoreFilledEntities)) {
                                highlight = "error";
                                replayError = new CLM.ReplayErrorActionUnavailable(userText);
                                replayErrors.push(replayError);
                            }
                        }
                        // Check that action (if not first) is after a wait action
                        if (scoreIndex > 0) {
                            const lastScoredAction = round.scorerSteps[scoreIndex - 1].labelAction;
                            let lastAction = actions.find(a => a.actionId == lastScoredAction);
                            if (lastAction && lastAction.isTerminal) {
                                highlight = "error";
                                replayError = new CLM.ReplayErrorActionAfterWait();
                                replayErrors.push(replayError);
                            }
                        }
                        // Generate bot response
                        curAction = actions.filter((a) => a.actionId === labelAction)[0];
                        let botResponse;
                        if (!curAction) {
                            botResponse = {
                                logicResult: undefined,
                                response: CLDebug_1.CLDebug.Error(`Can't find Action Id ${labelAction}`)
                            };
                        }
                        else {
                            // Create map with names and ids
                            let filledEntityMap = this.CreateFilledEntityMap(scoreFilledEntities, entityList);
                            // Fill in missing entities with a warning
                            const missingEntities = this.PopulateMissingFilledEntities(curAction, filledEntityMap, entities);
                            // Entity required for Action isn't filled in
                            if (missingEntities.length > 0) {
                                highlight = "error";
                                replayError = new CLM.ReplayErrorEntityEmpty(missingEntities);
                                replayErrors.push(replayError);
                            }
                            // Set memory from map with names only (since not calling APIs)
                            let memoryMap = CLM.FilledEntityMap.FromFilledEntities(scoreFilledEntities, entities);
                            yield clMemory.BotMemory.RestoreFromMapAsync(memoryMap);
                            if (curAction.actionType === CLM.ActionTypes.CARD) {
                                const cardAction = new CLM.CardAction(curAction);
                                botResponse = {
                                    logicResult: undefined,
                                    response: yield this.TakeCardAction(cardAction, filledEntityMap)
                                };
                            }
                            else if (curAction.actionType === CLM.ActionTypes.API_LOCAL) {
                                const apiAction = new CLM.ApiAction(curAction);
                                const actionInput = {
                                    type: ActionInputType.RENDER_ONLY,
                                    value: scorerStep.logicResult
                                };
                                botResponse = yield this.TakeAPIAction(apiAction, filledEntityMap, clMemory, entityList.entities, true, actionInput);
                            }
                            else if (curAction.actionType === CLM.ActionTypes.TEXT) {
                                const textAction = new CLM.TextAction(curAction);
                                botResponse = {
                                    logicResult: undefined,
                                    response: yield this.TakeTextAction(textAction, filledEntityMap)
                                };
                            }
                            else if (curAction.actionType === CLM.ActionTypes.END_SESSION) {
                                const sessionAction = new CLM.SessionAction(curAction);
                                let sessionInfo = yield clMemory.BotState.SessionInfoAsync();
                                botResponse = {
                                    logicResult: undefined,
                                    response: yield this.TakeSessionAction(sessionAction, filledEntityMap, true, sessionInfo.userId, null)
                                };
                            }
                            // TODO
                            //  TakeAzureAPIAction
                            else {
                                throw new Error(`Cannot construct bot response for unknown action type: ${curAction.actionType}`);
                            }
                        }
                        let downarrow = null;
                        if (curAction && !curAction.isTerminal) {
                            if (round.scorerSteps.length === scoreIndex + 1) {
                                downarrow = "wc-message-downarrow-points-red";
                            }
                            else {
                                downarrow = "wc-message-downarrow-points";
                            }
                        }
                        let channelData = {
                            senderType: CLM.SenderType.Bot,
                            roundIndex: roundNum,
                            scoreIndex,
                            highlight,
                            downarrow: downarrow,
                            replayError
                        };
                        let botActivity = null;
                        let botId = `BOT-${userId}`;
                        if (typeof botResponse.response == 'string') {
                            botActivity = {
                                id: CLM.ModelUtils.generateGUID(),
                                from: { id: botId, name: CLM.CL_USER_NAME_ID, role: BB.RoleTypes.Bot },
                                type: 'message',
                                text: botResponse.response,
                                channelData: channelData
                            };
                        }
                        else if (botResponse) {
                            botActivity = botResponse.response;
                            botActivity.id = CLM.ModelUtils.generateGUID();
                            botActivity.from = { id: botId, name: CLM.CL_USER_NAME_ID, role: BB.RoleTypes.Bot };
                            botActivity.channelData = channelData;
                        }
                        if (botActivity) {
                            activities.push(botActivity);
                        }
                    }
                }
            }
            let memories = yield clMemory.BotMemory.DumpMemory();
            let hasRounds = trainDialog.rounds.length > 0;
            let hasScorerRound = (hasRounds && trainDialog.rounds[trainDialog.rounds.length - 1].scorerSteps.length > 0);
            let dialogMode = CLM.DialogMode.Scorer;
            // If I have no rounds, I'm waiting for input
            if (!hasRounds) {
                dialogMode = CLM.DialogMode.Wait;
            }
            else if (curAction) {
                // If last action is session end
                if (curAction.actionType === CLM.ActionTypes.END_SESSION) {
                    dialogMode = CLM.DialogMode.EndSession;
                }
                // If I have a scorer round, wait
                else if (curAction.isTerminal && hasScorerRound) {
                    dialogMode = CLM.DialogMode.Wait;
                }
            }
            // Calculate last extract response from text variations
            let uiScoreInput;
            if (hasRounds) {
                // Note: Could potentially just send back extractorStep and calculate extractResponse on other end
                let textVariations = trainDialog.rounds[trainDialog.rounds.length - 1].extractorStep.textVariations;
                let extractResponses = CLM.ModelUtils.ToExtractResponses(textVariations);
                let trainExtractorStep = trainDialog.rounds[trainDialog.rounds.length - 1].extractorStep;
                uiScoreInput = {
                    trainExtractorStep: trainExtractorStep,
                    extractResponse: extractResponses[0]
                };
            }
            // Make errors unique using Set operator
            replayErrors = [...new Set(replayErrors)];
            let teachWithHistory = {
                teach: undefined,
                scoreInput: undefined,
                scoreResponse: undefined,
                uiScoreInput: uiScoreInput,
                extractResponse: undefined,
                lastAction: curAction,
                history: activities,
                memories: memories,
                prevMemories: prevMemories,
                dialogMode: dialogMode,
                replayErrors: replayErrors
            };
            return teachWithHistory;
        });
    }
    // Generate a card to show for an API action w/o output
    APICard(callback) {
        let card = {
            type: "AdaptiveCard",
            version: "1.0",
            body: [
                {
                    type: "TextBlock",
                    text: `{
    name: ${callback.name},
    logic: (memoryManager${callback.logicArguments.length > 0 ? `, ${callback.logicArguments.join(', ')}` : ''}),
    render: (result, memoryManager${callback.renderArguments.length > 0 ? `, ${callback.renderArguments.join(', ')}` : ''})
`
                }
            ]
        };
        const attachment = BB.CardFactory.adaptiveCard(card);
        const message = BB.MessageFactory.attachment(attachment);
        return message;
    }
}
/* Lookup table for CLRunners.  One CLRunner per CL Model */
CLRunner.Runners = {};
exports.CLRunner = CLRunner;
//# sourceMappingURL=CLRunner.js.map