"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const CLDebug_1 = require("../CLDebug");
const MESSAGE_TIMEOUT = 10000;
class InputQueue {
    static AddInput(botState, request, conversationReference, callback) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!request.id) {
                return null;
            }
            // Add to queue
            yield InputQueue.InputQueueAdd(request.id, callback);
            // Process queue
            yield InputQueue.InputQueueProcess(botState);
        });
    }
    // Add message to queue
    static InputQueueAdd(conversationId, callback) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const now = new Date().getTime();
            const queuedInput = {
                conversationId: conversationId,
                timestamp: now,
                callback: callback
            };
            this.messageQueue.push(queuedInput);
            CLDebug_1.CLDebug.Log(`ADD QUEUE: ${conversationId} ${this.messageQueue.length}`, CLDebug_1.DebugType.MessageQueue);
        });
    }
    // Attempt to process next message in the queue
    static InputQueueProcess(botState) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const now = new Date().getTime();
            const messageProcessing = yield botState.GetMessageProcessing();
            // Is a message being processed
            if (messageProcessing) {
                // Remove if it's been expired
                const age = now - messageProcessing.timestamp;
                if (age > MESSAGE_TIMEOUT) {
                    CLDebug_1.CLDebug.Log(`EXPIRED: ${messageProcessing.conversationId} ${this.messageQueue.length}`, CLDebug_1.DebugType.MessageQueue);
                    yield botState.MessageProcessingPopAsync();
                    let queuedInput = this.messageQueue.find(mq => mq.conversationId == messageProcessing.conversationId);
                    if (queuedInput) {
                        // Fire the callback with failure
                        queuedInput.callback(true, queuedInput.conversationId);
                    }
                    else {
                        CLDebug_1.CLDebug.Log(`EXPIRE-WARNING: Couldn't find queud message`, CLDebug_1.DebugType.MessageQueue);
                    }
                    CLDebug_1.CLDebug.Log(`EXPIRE-POP: ${messageProcessing.conversationId} ${this.messageQueue.length}`, CLDebug_1.DebugType.MessageQueue);
                }
            }
            // If no message being processed, try next message
            if (!messageProcessing) {
                yield InputQueue.InputQueueProcessNext(botState);
            }
        });
    }
    // Process next message
    static InputQueueProcessNext(botState) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let curProcessing = yield botState.GetMessageProcessing();
            // If no message being process, and item in queue, process teh next one
            if (!curProcessing && this.messageQueue.length > 0) {
                let messageProcessing = this.messageQueue.shift();
                if (messageProcessing) {
                    yield botState.SetMessageProcessing(messageProcessing);
                    // Fire the callback with success
                    CLDebug_1.CLDebug.Log(`PROCESS-CALLBACK: ${messageProcessing.conversationId} ${this.messageQueue.length}`, CLDebug_1.DebugType.MessageQueue);
                    messageProcessing.callback(false, messageProcessing.conversationId);
                }
                else {
                    CLDebug_1.CLDebug.Log(`PROCESS-ERR: No Message`, CLDebug_1.DebugType.MessageQueue);
                }
            }
            else {
                CLDebug_1.CLDebug.Log(`PROCESS-NEXT: Empty`, CLDebug_1.DebugType.MessageQueue);
            }
        });
    }
    // Done processing message, remove from queue
    static MessageHandled(botState, conversationId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!conversationId) {
                CLDebug_1.CLDebug.Log(`HANDLE: Missing conversation id`, CLDebug_1.DebugType.MessageQueue);
            }
            let messageProcessing = yield botState.MessageProcessingPopAsync();
            // Check for consistency
            if (messageProcessing && messageProcessing.conversationId === conversationId) {
                CLDebug_1.CLDebug.Log(`HANDLE-POP: ${messageProcessing.conversationId} ${this.messageQueue.length}`, CLDebug_1.DebugType.MessageQueue);
            }
            // Process next message in the queue
            yield InputQueue.InputQueueProcessNext(botState);
        });
    }
}
InputQueue.messageQueue = [];
exports.InputQueue = InputQueue;
//# sourceMappingURL=InputQueue.js.map