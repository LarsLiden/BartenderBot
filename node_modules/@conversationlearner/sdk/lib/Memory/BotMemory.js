"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const CLDebug_1 = require("../CLDebug");
const models_1 = require("@conversationlearner/models");
const NEGATIVE_PREFIX = '~';
class BotMemory {
    constructor(init) {
        this.filledEntityMap = new models_1.FilledEntityMap();
        Object.assign(this, init);
    }
    static Get(clMemory) {
        if (!BotMemory._instance) {
            BotMemory._instance = new BotMemory();
        }
        BotMemory._instance.clMemory = clMemory;
        return BotMemory._instance;
    }
    FilledEntityMap() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.Init();
            return this.filledEntityMap;
        });
    }
    Init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.clMemory) {
                throw new Error('BotMemory called without initializing memory');
            }
            let data = yield this.clMemory.GetAsync(BotMemory.MEMKEY);
            if (data) {
                this.Deserialize(data);
            }
            else {
                this.ClearAsync();
            }
        });
    }
    Serialize() {
        return JSON.stringify(this.filledEntityMap.map);
    }
    Deserialize(text) {
        if (!text) {
            return;
        }
        let json = JSON.parse(text);
        this.filledEntityMap.map = json ? json : {};
    }
    Set() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.clMemory) {
                throw new Error('BotMemory called without initializing memory');
            }
            yield this.clMemory.SetAsync(BotMemory.MEMKEY, this.Serialize());
        });
    }
    RestoreFromMapAsync(filledEntityMap) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.filledEntityMap.map = filledEntityMap.map;
            yield this.Set();
        });
    }
    RestoreFromMemoryManagerAsync(memoryManager) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Disable memory manager.  Use has been completed
            memoryManager.__Expire();
            this.filledEntityMap.map = memoryManager.curMemories.map;
            yield this.Set();
        });
    }
    // Clear memory values not in saveList
    ClearAsync(saveList) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!saveList) {
                this.filledEntityMap = new models_1.FilledEntityMap();
            }
            else {
                for (let key of Object.keys(this.filledEntityMap.map)) {
                    if (saveList.indexOf(key) < 0) {
                        delete this.filledEntityMap.map[key];
                    }
                }
            }
            yield this.Set();
        });
    }
    // Remember value for an entity
    RememberEntity(entityName, entityId, entityValue, isBucket = false, builtinType = null, resolution = null) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.Init();
            this.filledEntityMap.Remember(entityName, entityId, entityValue, isBucket, builtinType, resolution);
            yield this.Set();
        });
    }
    // Remember multiple values for an entity
    RememberMany(entityName, entityId, entityValues, isBucket = false, builtinType = null, resolution = null) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.Init();
            this.filledEntityMap.RememberMany(entityName, entityId, entityValues, isBucket, builtinType, resolution);
            yield this.Set();
        });
    }
    /** Return array of entity names for which I've remembered something */
    RememberedNames() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.Init();
            return Object.keys(this.filledEntityMap);
        });
    }
    /** Return array of entity Ids for which I've remembered something */
    FilledEntitiesAsync() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.Init();
            return this.filledEntityMap.FilledEntities();
        });
    }
    /** Given negative entity name, return positive version */
    PositiveName(negativeName) {
        if (negativeName.startsWith(NEGATIVE_PREFIX)) {
            return negativeName.slice(1);
        }
        return null;
    }
    /** Forget a predicted Entity */
    ForgetEntity(entityName, entityValue, isMultiValue) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let posName = this.PositiveName(entityName);
            if (posName) {
                yield this.Forget(posName, entityValue, isMultiValue);
            }
        });
    }
    /** Forget an entity value */
    Forget(entityName, entityValue = null, isBucket = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                // Check if entity buckets values
                yield this.Init();
                this.filledEntityMap.Forget(entityName, entityValue, isBucket);
                yield this.Set();
            }
            catch (error) {
                CLDebug_1.CLDebug.Error(error);
            }
        });
    }
    DumpMemory() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Check if entity buckets values
            yield this.Init();
            let memory = [];
            for (let entityName in this.filledEntityMap.map) {
                memory.push({ entityName: entityName, entityValues: this.MemoryValues(entityName) });
            }
            return memory;
        });
    }
    Value(entityName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.Init();
            return this.filledEntityMap.ValueAsString(entityName);
        });
    }
    ValueAsList(entityName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.Init();
            return this.filledEntityMap.ValueAsList(entityName);
        });
    }
    ValueAsPrebuilt(entityName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.Init();
            return this.MemoryValues(entityName);
        });
    }
    MemoryValues(entityName) {
        if (!this.filledEntityMap.map[entityName]) {
            return [];
        }
        return this.filledEntityMap.map[entityName].values;
    }
}
BotMemory.MEMKEY = 'BOTMEMORY';
exports.BotMemory = BotMemory;
//# sourceMappingURL=BotMemory.js.map