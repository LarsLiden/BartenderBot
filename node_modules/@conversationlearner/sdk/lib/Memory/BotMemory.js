"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const CLDebug_1 = require("../CLDebug");
const Utils_1 = require("../Utils");
const models_1 = require("@conversationlearner/models");
const NEGATIVE_PREFIX = '~';
class BotMemory {
    constructor(init) {
        this.filledEntities = new models_1.FilledEntityMap();
        Object.assign(this, init);
    }
    static Get(clMemory) {
        if (!BotMemory._instance) {
            BotMemory._instance = new BotMemory();
        }
        BotMemory._instance.memory = clMemory;
        return BotMemory._instance;
    }
    FilledEntityMap() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.Init();
            return this.filledEntities;
        });
    }
    Init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.memory) {
                throw new Error('BotMemory called without initialzing memory');
            }
            let data = yield this.memory.GetAsync(BotMemory.MEMKEY);
            if (data) {
                this.Deserialize(data);
            }
            else {
                this.ClearAsync();
            }
        });
    }
    Serialize() {
        return JSON.stringify(this.filledEntities.map);
    }
    Deserialize(text) {
        if (!text) {
            return;
        }
        let json = JSON.parse(text);
        this.filledEntities.map = json ? json : {};
    }
    Set() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.memory) {
                throw new Error('BotMemory called without initialzing memory');
            }
            yield this.memory.SetAsync(BotMemory.MEMKEY, this.Serialize());
        });
    }
    RestoreFromMap(filledEntityMap) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.filledEntities = new models_1.FilledEntityMap();
            yield this.Set();
        });
    }
    ClearAsync() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.filledEntities = new models_1.FilledEntityMap();
            yield this.Set();
        });
    }
    // Intenral: Remember value for an entity (assumes init has happend and save will happen after
    Remember(entityName, entityId, entityValue, isBucket = false, builtinType = null, 
    // TODO: Add stronger type safety
    resolution = null) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.filledEntities.map[entityName]) {
                this.filledEntities.map[entityName] = {
                    entityId: entityId,
                    values: []
                };
            }
            let displayText = builtinType ? Utils_1.Utils.PrebuiltDisplayText(builtinType, resolution, entityValue) : null;
            const filledEntity = this.filledEntities.map[entityName];
            // Check if entity buckets values
            if (isBucket) {
                // Add if not a duplicate
                const containsDuplicateValue = filledEntity.values.some(memoryValue => memoryValue.userText === entityValue);
                if (!containsDuplicateValue) {
                    filledEntity.values.push({
                        userText: entityValue,
                        displayText: displayText,
                        builtinType: builtinType,
                        resolution: resolution
                    });
                }
            }
            else {
                filledEntity.values = [{ userText: entityValue, displayText: displayText, builtinType: builtinType, resolution: resolution }];
            }
        });
    }
    // Remember value for an entity
    RememberEntity(entityName, entityId, entityValue, isBucket = false, builtinType = null, resolution = null) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.Init();
            this.Remember(entityName, entityId, entityValue, isBucket, builtinType, resolution);
            yield this.Set();
        });
    }
    // Remember multiple values for an entity
    RememberMany(entityName, entityId, entityValues, isBucket = false, builtinType = null, resolution = null) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.Init();
            for (let entityValue of entityValues) {
                this.Remember(entityName, entityId, entityValue, isBucket, builtinType, resolution);
            }
            yield this.Set();
        });
    }
    /** Return array of entity names for which I've remembered something */
    RememberedNames() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.Init();
            return Object.keys(this.filledEntities);
        });
    }
    /** Return array of entity Ids for which I've remembered something */
    FilledEntitiesAsync() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.Init();
            return Object.keys(this.filledEntities.map).map(val => {
                return this.filledEntities.map[val];
            });
        });
    }
    /** Given negative entity name, return positive version */
    PositiveName(negativeName) {
        if (negativeName.startsWith(NEGATIVE_PREFIX)) {
            return negativeName.slice(1);
        }
        return null;
    }
    /** Forget a predicted Entity */
    ForgetEntity(entityName, entityValue, isMultivalue) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let posName = this.PositiveName(entityName);
            if (posName) {
                yield this.Forget(posName, entityValue, isMultivalue);
            }
        });
    }
    /** Forget an entity value */
    Forget(entityName, entityValue = null, isBucket = false) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                // Check if entity buckets values
                yield this.Init();
                if (isBucket) {
                    // Entity might not be in memory
                    if (!this.filledEntities.map[entityName]) {
                        return;
                    }
                    // If no entity Value provide, clear the entity
                    if (!entityValue) {
                        delete this.filledEntities.map[entityName];
                    }
                    else {
                        // Find case insensitive index
                        let lowerCaseNames = this.filledEntities.map[entityName].values
                            .filter(mv => mv.userText)
                            .map(mv => mv.userText.toLowerCase());
                        let index = lowerCaseNames.indexOf(entityValue.toLowerCase());
                        if (index > -1) {
                            this.filledEntities.map[entityName].values.splice(index, 1);
                            if (this.filledEntities.map[entityName].values.length == 0) {
                                delete this.filledEntities.map[entityName];
                            }
                        }
                    }
                }
                else {
                    delete this.filledEntities.map[entityName];
                }
                yield this.Set();
            }
            catch (error) {
                CLDebug_1.CLDebug.Error(error);
            }
        });
    }
    DumpMemory() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // Check if entity buckets values
            yield this.Init();
            let memory = [];
            for (let entityName in this.filledEntities.map) {
                memory.push({ entityName: entityName, entityValues: this.MemoryValues(entityName) });
            }
            return memory;
        });
    }
    Value(entityName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.Init();
            return this.filledEntities.EntityValueAsString(entityName);
        });
    }
    ValueAsList(entityName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.Init();
            return this.filledEntities.EntityValueAsList(entityName);
        });
    }
    ValueAsPrebuilt(entityName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.Init();
            return this.MemoryValues(entityName);
        });
    }
    MemoryValues(entityName) {
        if (!this.filledEntities.map[entityName]) {
            return [];
        }
        return this.filledEntities.map[entityName].values;
    }
}
BotMemory._instance = null;
BotMemory.MEMKEY = 'BOTMEMORY';
exports.BotMemory = BotMemory;
//# sourceMappingURL=BotMemory.js.map