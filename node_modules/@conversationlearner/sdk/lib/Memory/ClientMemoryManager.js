"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const CLDebug_1 = require("../CLDebug");
const models_1 = require("@conversationlearner/models");
class ClientMemoryManager {
    constructor(botMemory, prevMemories, entities, sessionInfo) {
        this.entities = [];
        this.entities = entities;
        this.botMemory = botMemory;
        this.sessionInfo = sessionInfo;
        this.prevMemories = prevMemories;
    }
    static CreateAsync(clMemory, entities) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let sessionInfo = yield clMemory.BotState.SessionInfoAsync();
            let prevMemories = new models_1.FilledEntityMap(yield clMemory.BotMemory.FilledEntityMap());
            return new ClientMemoryManager(clMemory.BotMemory, prevMemories, entities, sessionInfo);
        });
    }
    FindEntity(entityName) {
        let match = this.entities.find(e => e.entityName == entityName);
        return match;
    }
    RememberEntityAsync(entityName, entityValue) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let entity = this.FindEntity(entityName);
            if (!entity) {
                CLDebug_1.CLDebug.Error(`Can't find Entity named: ${entityName}`);
                return;
            }
            if (typeof entityValue == 'object') {
                entityValue = JSON.stringify(entityValue);
            }
            else if (typeof entityValue == 'number') {
                entityValue = entityValue.toString();
            }
            yield this.botMemory.RememberEntity(entity.entityName, entity.entityId, entityValue, entity.isMultivalue);
        });
    }
    RememberEntitiesAsync(entityName, entityValues) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let entity = this.FindEntity(entityName);
            if (!entity) {
                CLDebug_1.CLDebug.Error(`Can't find Entity named: ${entityName}`);
                return;
            }
            if (!entity.isMultivalue) {
                CLDebug_1.CLDebug.Error(`RememberEntitiesAsync called on entity (${entityName}) that isn't Multi-Value.  Only the last value will be remembered`);
            }
            yield this.botMemory.RememberMany(entity.entityName, entity.entityId, entityValues, entity.isMultivalue);
        });
    }
    ForgetEntityAsync(entityName, value = null) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let entity = this.FindEntity(entityName);
            if (!entity) {
                CLDebug_1.CLDebug.Error(`Can't find Entity named: ${entityName}`);
                return;
            }
            // If no value given, wipe all entites from buckets
            yield this.botMemory.Forget(entity.entityName, value, entity.isMultivalue);
        });
    }
    /** Clear all entity values apart from any included in the list of saveEntityNames
     * Useful in the "onSessionEndCallback" to preserve a subset of entities for the next session
     */
    ForgetAllEntitiesAsync(saveEntityNames) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            for (let entity of this.entities) {
                if (saveEntityNames.indexOf(entity.entityName) < 0) {
                    yield this.botMemory.Forget(entity.entityName, null, entity.isMultivalue);
                }
            }
        });
    }
    CopyEntityAsync(entityNameFrom, entityNameTo) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let entityFrom = this.FindEntity(entityNameFrom);
            let entityTo = this.FindEntity(entityNameTo);
            if (!entityFrom) {
                CLDebug_1.CLDebug.Error(`Can't find Entity named: ${entityNameFrom}`);
                return;
            }
            if (!entityTo) {
                CLDebug_1.CLDebug.Error(`Can't find Entity named: ${entityNameTo}`);
                return;
            }
            if (entityFrom.isMultivalue != entityTo.isMultivalue) {
                CLDebug_1.CLDebug.Error(`Can't copy between Bucket and Non-Bucket Entities`);
                return;
            }
            // Clear "To" entity
            yield this.botMemory.Forget(entityNameTo);
            // Get value of "From" entity
            let values = yield this.botMemory.ValueAsList(entityNameFrom);
            // Copy values from "From"
            for (let value of values) {
                yield this.RememberEntityAsync(entityNameTo, value);
            }
        });
    }
    EntityValueAsync(entityName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.botMemory.Value(entityName);
        });
    }
    EntityValueAsPrebuiltAsync(entityName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.botMemory.ValueAsPrebuilt(entityName);
        });
    }
    EntityValueAsListAsync(entityName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.botMemory.ValueAsList(entityName);
        });
    }
    EntityValueAsNumberAsync(entityName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const textObj = yield this.botMemory.Value(entityName);
            let number = Number(textObj);
            if (isNaN(number)) {
                CLDebug_1.CLDebug.Error(`EntityValueAsNumberAsync: Entity value "${textObj}" is not number`);
                return null;
            }
            return number;
        });
    }
    EntityValueAsBooleanAsync(entityName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const textObj = yield this.botMemory.Value(entityName);
            if (textObj) {
                if (textObj.toLowerCase() === 'true') {
                    return true;
                }
                if (textObj.toLowerCase() === 'false') {
                    return false;
                }
            }
            CLDebug_1.CLDebug.Error(`EntityValueAsBooleanAsync: Entity value "${textObj}" is not boolean`);
            return null;
        });
    }
    EntityValueAsObjectAsync(entityName) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const textObj = yield this.botMemory.Value(entityName);
            if (textObj) {
                return JSON.parse(textObj);
            }
            CLDebug_1.CLDebug.Error(`EntityValueAsObjectAsync: Entity value "${textObj}" is not an object`);
            return null;
        });
    }
    PrevEntityValue(entityName) {
        return this.prevMemories.EntityValueAsString(entityName);
    }
    PrevEntityValueAsPrebuilt(entityName) {
        if (!this.prevMemories.map[entityName]) {
            return [];
        }
        return this.prevMemories.map[entityName].values;
    }
    PrevEntityValueAsList(entityName) {
        return this.prevMemories.EntityValueAsList(entityName);
    }
    PrevValueAsNumber(entityName) {
        const textObj = this.prevMemories.EntityValueAsString(entityName);
        let number = Number(textObj);
        if (isNaN(number)) {
            CLDebug_1.CLDebug.Error(`PrevValueAsNumber: Entity value "${textObj}" is not number`);
            return null;
        }
        return number;
    }
    PrevValueAsBoolean(entityName) {
        const textObj = this.prevMemories.EntityValueAsString(entityName);
        if (textObj) {
            if (textObj.toLowerCase() === 'true') {
                return true;
            }
            if (textObj.toLowerCase() === 'false') {
                return false;
            }
        }
        CLDebug_1.CLDebug.Error(`PrevValueAsBoolean: Entity value "${textObj}" is not boolean`);
        return null;
    }
    PrevEntityValueAsObject(entityName) {
        const textObj = this.prevMemories.EntityValueAsString(entityName);
        if (textObj) {
            return JSON.parse(textObj);
        }
        return null;
    }
    GetFilledEntitiesAsync() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.botMemory.FilledEntitiesAsync();
        });
    }
    SessionInfo() {
        return this.sessionInfo;
    }
}
exports.ClientMemoryManager = ClientMemoryManager;
//# sourceMappingURL=ClientMemoryManager.js.map