"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const ConversationLearner_1 = require("../ConversationLearner");
const CLRunner_1 = require("../CLRunner");
var BotStateType;
(function (BotStateType) {
    // Currently running application
    BotStateType["APP"] = "APP";
    // Conversation Id associated with this session
    BotStateType["CONVERSATION_ID"] = "CONVERSATION_ID";
    // BotBuilder conversation reference
    BotStateType["CONVERSATION_REFERENCE"] = "CONVERSATION_REFERENCE";
    // Which packages are active for editing
    BotStateType["EDITING_PACKAGE"] = "EDITING_PACKAGE";
    // Is current session a teach session
    BotStateType["IN_TEACH"] = "IN_TEACH";
    // Last time active session was used (in ticks)
    BotStateType["LAST_ACTIVE"] = "LAST_ACTIVE";
    // If session is a chat session what is logDialogId
    BotStateType["LOG_DIALOG_ID"] = "LOG_DIALOG_ID";
    // Current message being processed
    BotStateType["MESSAGE_MUTEX"] = "MESSAGE_MUTEX";
    // True if onEndSession needs to be called
    BotStateType["NEED_SESSIONEND_CALL"] = "ON_ENDSESSION_CALLED";
    // If session is continuation of times out session, what was the original sessionId
    BotStateType["ORIG_SESSION"] = "ORIG_SESSION";
    // Currently active session
    BotStateType["SESSION_ID"] = "SESSION_ID";
})(BotStateType = exports.BotStateType || (exports.BotStateType = {}));
class BotState {
    constructor(init) {
        Object.assign(this, init);
    }
    static Get(clMemory) {
        if (!BotState._instance) {
            BotState._instance = new BotState();
        }
        BotState._instance.memory = clMemory;
        return BotState._instance;
    }
    GetStateAsync(botStateType) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.memory) {
                throw new Error('BotState called without initializing memory');
            }
            try {
                let data = yield this.memory.GetAsync(botStateType);
                return JSON.parse(data);
            }
            catch (_a) {
                // If brand new use, need to initialize
                yield this._SetAppAsync(null);
                let data = yield this.memory.GetAsync(botStateType);
                return JSON.parse(data);
            }
        });
    }
    SetStateAsync(botStateType, value) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!this.memory) {
                throw new Error('BotState called without initializing memory');
            }
            const json = JSON.stringify(value);
            yield this.memory.SetAsync(botStateType, json);
        });
    }
    // NOTE: CLMemory should be the only one to call this
    _SetAppAsync(app) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.SetApp(app);
            yield this.SetConversationId(null);
            yield this.SetConversationReference(null);
            yield this.SetLastActive(0);
            yield this.SetMessageProcessing(null);
            yield this.SetOrgSessionId(null);
            yield this.SetNeedSessionEndCall(false);
            yield this.SetInTeach(false);
            yield this.SetSessionId(null);
            yield this.SetLogDialogId(null);
            yield this.ClearEditingPackageAsync();
        });
    }
    // ------------------------------------------------
    //  APP
    // ------------------------------------------------
    GetApp() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                return yield this.GetStateAsync(BotStateType.APP);
            }
            catch (err) {
                return null;
            }
        });
    }
    SetApp(app) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (!app) {
                yield this.SetStateAsync(BotStateType.APP, null);
            }
            else {
                // Store only needed data
                let smallApp = {
                    appId: app.appId,
                    appName: app.appName,
                    livePackageId: app.livePackageId,
                    devPackageId: app.devPackageId,
                    metadata: {
                        isLoggingOn: app.metadata.isLoggingOn
                    }
                };
                yield this.SetStateAsync(BotStateType.APP, smallApp);
            }
        });
    }
    // ------------------------------------------------
    //  CONVERSATION_ID
    // ------------------------------------------------
    GetConversationId() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.GetStateAsync(BotStateType.CONVERSATION_ID);
        });
    }
    SetConversationId(conversationId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.SetStateAsync(BotStateType.CONVERSATION_ID, conversationId);
        });
    }
    // ------------------------------------------------
    //  EDITING_PACKAGE
    // ------------------------------------------------
    GetEditingPackages() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return (yield this.GetStateAsync(BotStateType.EDITING_PACKAGE)) || {};
        });
    }
    SetEditingPackage(appId, packageId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let activeApps = (yield this.GetStateAsync(BotStateType.EDITING_PACKAGE)) || {};
            activeApps[appId] = packageId;
            yield this.SetStateAsync(BotStateType.EDITING_PACKAGE, activeApps);
            return activeApps;
        });
    }
    GetEditingPackageForApp(appId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let activeApps = (yield this.GetStateAsync(BotStateType.EDITING_PACKAGE)) || {};
            return activeApps[appId];
        });
    }
    ClearEditingPackageAsync() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.SetStateAsync(BotStateType.EDITING_PACKAGE, {});
        });
    }
    // ------------------------------------------------
    //  ORIG_SESSION
    // ------------------------------------------------
    OrgSessionIdAsync(sessionId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const origSessionId = yield this.GetStateAsync(BotStateType.ORIG_SESSION);
            // If session expired and was replaced with a more recent one, return the new sessionId
            if (origSessionId === sessionId) {
                const curSessionId = yield this.GetStateAsync(BotStateType.SESSION_ID);
                return curSessionId;
            }
            return sessionId;
        });
    }
    GetOrgSessionIdAsync() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.GetStateAsync(BotStateType.ORIG_SESSION);
        });
    }
    SetOrgSessionId(sessionId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.SetStateAsync(BotStateType.ORIG_SESSION, sessionId);
        });
    }
    // ------------------------------------------------
    // NEED_SESSIONEND_CALL
    // ------------------------------------------------
    GetNeedSessionEndCall() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const needed = yield this.GetStateAsync(BotStateType.NEED_SESSIONEND_CALL);
            return (needed ? needed : false);
        });
    }
    SetNeedSessionEndCall(needed) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            needed = needed ? needed : false;
            yield this.SetStateAsync(BotStateType.NEED_SESSIONEND_CALL, needed);
        });
    }
    // ------------------------------------------------
    // LAST_ACTIVE
    // ------------------------------------------------
    GetLastActive() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.GetStateAsync(BotStateType.LAST_ACTIVE);
        });
    }
    SetLastActive(lastActive) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.SetStateAsync(BotStateType.LAST_ACTIVE, lastActive);
        });
    }
    // ------------------------------------------------
    // SESSION_ID
    // ------------------------------------------------
    GetSessionIdAndSetConversationId(conversationId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            // If conversationId not set yet, use the session and set it
            let existingConversationId = yield this.GetConversationId();
            if (!existingConversationId) {
                yield this.SetConversationId(conversationId);
                return yield this.GetStateAsync(BotStateType.SESSION_ID);
            }
            // If conversation Id matches return the sessionId
            else if (existingConversationId == conversationId) {
                return yield this.GetStateAsync(BotStateType.SESSION_ID);
            }
            // Otherwise session is for another conversation
            return null;
        });
    }
    SetSessionId(sessionId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.SetStateAsync(BotStateType.SESSION_ID, sessionId);
        });
    }
    InitSessionAsync(sessionId, logDialogId, conversationId, sessionStartFlags) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.SetSessionId(sessionId);
            // Do not clear OrgSessionId, if user did manual timeout, so UI can properly delete
            if (!(sessionStartFlags & CLRunner_1.SessionStartFlags.IS_MANUAL_TIMEOUT)) {
                yield this.SetOrgSessionId(null);
            }
            yield this.SetLogDialogId(logDialogId);
            yield this.SetNeedSessionEndCall(true);
            yield this.SetConversationId(conversationId);
            yield this.SetLastActive(new Date().getTime());
            yield this.SetInTeach((sessionStartFlags & CLRunner_1.SessionStartFlags.IN_TEACH) > 0);
            yield this.SetMessageProcessing(null);
        });
    }
    // End a session.
    // originalSessionId is sent when session terminated from EndSession action or expiration
    EndSessionAsync(originalSessionId = null) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.SetSessionId(null);
            yield this.SetLogDialogId(null);
            if (originalSessionId) {
                let existingOrigSesionId = yield this.GetOrgSessionIdAsync();
                if (!existingOrigSesionId) {
                    yield this.SetOrgSessionId(originalSessionId);
                }
            }
            else {
                yield this.SetOrgSessionId(null);
            }
            yield this.SetConversationId(null);
            yield this.SetLastActive(0);
            yield this.SetInTeach(false);
            yield this.SetMessageProcessing(null);
        });
    }
    // ------------------------------------------------
    //  IN_TEACH
    // ------------------------------------------------
    GetInTeach() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const inTeach = yield this.GetStateAsync(BotStateType.IN_TEACH);
            return inTeach ? inTeach : false;
        });
    }
    SetInTeach(inTeach) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            inTeach = inTeach ? inTeach : false;
            yield this.SetStateAsync(BotStateType.IN_TEACH, inTeach);
        });
    }
    // ------------------------------------------------
    //  CONVERSATION_REFERENCE
    // ------------------------------------------------
    SetConversationReference(conversationReference) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.SetStateAsync(BotStateType.CONVERSATION_REFERENCE, conversationReference);
        });
    }
    GetConversationReverence() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.GetStateAsync(BotStateType.CONVERSATION_REFERENCE);
        });
    }
    // For initial pro-active message need to build conversation reference from scratch
    CreateConversationReference(userName, userId, conversationId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let conversationReference = {
                user: { name: userName, id: userId },
                conversation: { id: conversationId },
                channelId: 'emulator',
                // TODO: Refactor away from static coupling.  BotState needs to have access to options object through constructor
                // tslint:disable-next-line:no-http-string
                serviceUrl: `http://127.0.0.1:${ConversationLearner_1.ConversationLearner.options.botPort}`
            };
            this.SetConversationReference(conversationReference);
        });
    }
    // ------------------------------------------------
    //  LOG_DIALOG_ID
    // ------------------------------------------------
    GetLogDialogId() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.GetStateAsync(BotStateType.LOG_DIALOG_ID);
        });
    }
    SetLogDialogId(logDialogId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.SetStateAsync(BotStateType.LOG_DIALOG_ID, logDialogId);
        });
    }
    // ------------------------------------------------
    //  MESSAGE_MUTEX
    // ------------------------------------------------
    GetMessageProcessing() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return yield this.GetStateAsync(BotStateType.MESSAGE_MUTEX);
        });
    }
    MessageProcessingPopAsync() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let popVal = yield this.GetStateAsync(BotStateType.MESSAGE_MUTEX);
            yield this.SetStateAsync(BotStateType.MESSAGE_MUTEX, null);
            return popVal;
        });
    }
    SetMessageProcessing(queuedInput) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.SetStateAsync(BotStateType.MESSAGE_MUTEX, queuedInput);
        });
    }
    // -------------------------------------------------------------------
    SessionInfoAsync() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const conversationReference = yield this.GetConversationReverence();
            if (conversationReference && conversationReference.conversation) {
                return {
                    userName: conversationReference.user && conversationReference.user.name,
                    userId: conversationReference.user && conversationReference.user.id,
                    logDialogId: yield this.GetLogDialogId()
                };
            }
            return {
                userName: '',
                userId: '',
                logDialogId: ''
            };
        });
    }
}
exports.BotState = BotState;
//# sourceMappingURL=BotState.js.map