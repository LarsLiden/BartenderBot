"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
const CLMemory_1 = require("../CLMemory");
const CLDebug_1 = require("../CLDebug");
const MAX_BROWSER_SLOTS = 10;
/**
 * Used to keep track of memory slots used by open instances of the UI
 * Each browser instance uses a different slot, with a max number of
 * slots available
 */
class BrowserSlot {
    constructor(browserId, offset) {
        this.browserId = browserId;
        this.lastUsed = new Date().getTime();
        this.id = String.fromCharCode(offset + 65);
    }
    static GetSlot(browserId) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            let browserSlots = yield this.BrowserSlots();
            // Check if browser already has a spot
            let existingSlot = browserSlots.find(b => b.browserId === browserId);
            if (existingSlot) {
                existingSlot.lastUsed = new Date().getTime();
                yield this.UpdateBrowserSlots(browserSlots);
                return existingSlot.id;
            }
            // Add slot of spaces still availabled
            if (browserSlots.length < MAX_BROWSER_SLOTS) {
                let newSlot = new BrowserSlot(browserId, browserSlots.length);
                browserSlots.push(newSlot);
                yield this.UpdateBrowserSlots(browserSlots);
                return newSlot.id;
            }
            // Use oldest slot
            let oldestTime = browserSlots.reduce((min, b) => Math.min(min, b.lastUsed), browserSlots[0].lastUsed);
            let oldestSlot = browserSlots.find(b => b.lastUsed === oldestTime);
            if (!oldestSlot) {
                throw new Error("Slot not found. This should never happen.");
            }
            // Claim this slot
            oldestSlot.lastUsed = new Date().getTime();
            oldestSlot.browserId = browserId;
            yield this.UpdateBrowserSlots(browserSlots);
            return oldestSlot.id;
        });
    }
    static BrowserSlots() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                let memory = CLMemory_1.CLMemory.GetMemory("BROWSER");
                let data = yield memory.GetAsync("SLOTS");
                if (data) {
                    return JSON.parse(data);
                }
                return [];
            }
            catch (err) {
                CLDebug_1.CLDebug.Error(err, "BrowserSlots");
                return [];
            }
        });
    }
    static UpdateBrowserSlots(browserSlots) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            try {
                let memory = CLMemory_1.CLMemory.GetMemory("BROWSER");
                yield memory.SetAsync("SLOTS", JSON.stringify(browserSlots));
            }
            catch (err) {
                CLDebug_1.CLDebug.Error(err, "BrowserSlots");
            }
        });
    }
}
exports.BrowserSlot = BrowserSlot;
//# sourceMappingURL=BrowserSlot.js.map