/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
// TODO: Copied from ConversationLearner-UI. Need to improve Action design to find out how to consolidate knowledge to single layer
// Originally ConversationLearner-models was intended to know have to understand the tree structure which is why we added the
// pre-serialized 'text' field; however, now can't use the text field becuase it includes entity id's instead of human-readable names
// Instead of having to decide wether to perform substitutions from the serialized text or from the tree it's better to
// just have single method used everywhere
// Can't import because it's from ConversationLearner-UI
//import { NodeTypes } from "./models";
var NodeTypes;
(function (NodeTypes) {
    NodeTypes["Mention"] = "mention-inline-node";
    NodeTypes["Optional"] = "optional-inline-node";
})(NodeTypes || (NodeTypes = {}));
var defaultOptions = {
    fallbackToOriginal: false,
    preserveOptionalNodeWrappingCharacters: false
};
function serialize(value, entityValuesMap, userOptions) {
    if (userOptions === void 0) { userOptions = {}; }
    var options = __assign({}, defaultOptions, userOptions);
    var valueAsJson = typeof value.toJSON === 'function' ? value.toJSON() : value;
    var processedDocument = removeOptionalNodesWithoutEntityValues(valueAsJson.document, Array.from(entityValuesMap.keys()));
    return serializeNode(processedDocument, entityValuesMap, options);
}
/**
 * Given node return filter out optional nodes without matching values provided
 *
 * E.g. You are welcome[, $name] -> You are welcome
 * @param node Slate Node
 * @param entityValues Key Value pair of entity id to entity display value
 */
function removeOptionalNodesWithoutEntityValues(node, entityIds) {
    if (node.kind === 'inline' && node.type === NodeTypes.Optional) {
        var entityIdsWithinOptionalNode = getEntityIds(node);
        var hasValues = entityIdsWithinOptionalNode.every(function (x) { return entityIds.includes(x); });
        return hasValues ? node : undefined;
    }
    if (Array.isArray(node.nodes)) {
        node.nodes = node.nodes.map(function (n) { return removeOptionalNodesWithoutEntityValues(n, entityIds); }).filter(function (n) { return n; });
    }
    return node;
}
function getEntityIds(node) {
    var entityIds = [];
    // If current node is inline node which we know to have entityId then save it in the list
    if (node.kind === 'inline' && node.type === NodeTypes.Mention) {
        // This check is required because when input is Slate Value node is Immutable.Map object
        // but it could also be a node from value.toJSON()
        var data = typeof node.data.toJS === 'function' ? node.data.toJS() : node.data;
        var option = data.option;
        if (!option) {
            throw new Error("Attempting to serialize inline node but it did not have option");
        }
        var entityId = option.id;
        entityIds.push(entityId);
    }
    // Technically this would never get called because inline nodes shouldn't have other children which are inline nodes
    // however, it's good to have working depth-first-traversal anyways
    if (Array.isArray(node.nodes)) {
        var childrenEntityIds = node.nodes
            .map(function (n) { return getEntityIds(n); })
            .reduce(function (totalIds, nodeIds) { return totalIds.concat(nodeIds); }, []);
        entityIds.push.apply(entityIds, childrenEntityIds);
    }
    return entityIds;
}
function serializeNode(node, entityValues, options) {
    if (node.kind === 'text') {
        return node.leaves.map(function (n) { return n.text; }).join('');
    }
    var serializedChildNodes = node.nodes.map(function (n) { return serializeNode(n, entityValues, options); });
    if (node.kind === 'inline' && node.type === NodeTypes.Mention) {
        // This check is required because when input is Slate Value node is Immutable.Map object
        // but it could also be a node from value.toJSON()
        var data = typeof node.data.toJS === 'function' ? node.data.toJS() : node.data;
        if (!data.completed) {
            return serializedChildNodes.join('');
        }
        var option = data.option;
        if (!option) {
            throw new Error("Attempting to serialize inline node but it did not have option");
        }
        var entityId = option.id;
        var mapContainsEntity = entityValues.has(entityId);
        if (!mapContainsEntity) {
            if (options.fallbackToOriginal) {
                return serializedChildNodes.join('');
            }
            var entityValuesString = Array.from(entityValues.entries())
                .map(function (_a) {
                var id = _a[0], value = _a[1];
                return id + ": " + value;
            })
                .join(', ');
            throw new Error("Inline node representing entity " + entityId + " was NOT provided a value in the given entityValue map: [" + entityValuesString + "]");
        }
        return entityValues.get(entityId);
    }
    if (node.kind === 'document') {
        return serializedChildNodes.join('\n');
    }
    var serializedChildren = serializedChildNodes.join('');
    return node.kind === 'inline' && node.type === NodeTypes.Optional
        ? options.preserveOptionalNodeWrappingCharacters
            ? serializedChildren
            : serializedChildren.slice(1, -1)
        : serializedChildren;
}
var EntityIdSerializer = {
    serialize: serialize
};

/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var ActionTypes;
(function (ActionTypes) {
    ActionTypes["TEXT"] = "TEXT";
    ActionTypes["API_LOCAL"] = "API_LOCAL";
    ActionTypes["CARD"] = "CARD";
    ActionTypes["END_SESSION"] = "END_SESSION";
})(ActionTypes || (ActionTypes = {}));
var ActionBase = /** @class */ (function () {
    function ActionBase(action) {
        this.requiredEntities = [];
        this.negativeEntities = [];
        this.suggestedEntity = null;
        this.actionId = action.actionId;
        this.actionType = action.actionType;
        this.createdDateTime = action.createdDateTime;
        this.payload = action.payload;
        this.isTerminal = action.isTerminal;
        this.requiredEntitiesFromPayload = action.requiredEntitiesFromPayload || [];
        this.requiredEntities = action.requiredEntities || [];
        this.negativeEntities = action.negativeEntities || [];
        this.suggestedEntity = action.suggestedEntity || null;
        this.version = action.version;
        this.packageCreationId = action.packageCreationId;
        this.packageDeletionId = action.packageDeletionId;
    }
    // TODO: Refactor away from generic GetPayload for different action types
    // They all return strings but the strings are very different (Text is the substituted values, but other actions dont)
    // This causes issue of having to pass in entityValueMap even when it's not required, but making it optional ruins
    // safety for those places which should require it.
    // TODO: Remove ScoredAction since it doesn't have payload
    ActionBase.GetPayload = function (action, entityValues) {
        if (action.actionType === ActionTypes.TEXT) {
            /**
             * For backwards compatibility check if payload is of new TextPayload type
             * Ideally we would implement schema refactor:
             * 1. Make payloads discriminated unions (E.g. After checking the action.type, flow control knows the type of the payload property)
             * This removes the need for the GetPayload function and GetArguments which are brittle coding patterns.
             */
            try {
                var textPayload = JSON.parse(action.payload);
                return EntityIdSerializer.serialize(textPayload.json, entityValues);
            }
            catch (e) {
                var error = e;
                throw new Error("Error when attempting to parse text action payload. This might be an old action which was saved as a string.  Please create a new action. " + error.message);
            }
        }
        else if (action.actionType === ActionTypes.END_SESSION) {
            var textPayload = JSON.parse(action.payload);
            return EntityIdSerializer.serialize(textPayload.json, entityValues);
        }
        else if (ActionTypes.CARD === action.actionType) {
            var cardPayload = JSON.parse(action.payload);
            return cardPayload.payload;
        }
        else if (ActionTypes.API_LOCAL === action.actionType) {
            var actionPayload = JSON.parse(action.payload);
            return actionPayload.payload;
        }
        return action.payload;
    };
    /** Return arguments for an action */
    ActionBase.GetActionArguments = function (action) {
        if (ActionTypes.CARD === action.actionType) {
            var cardPayload = JSON.parse(action.payload);
            return cardPayload.arguments.map(function (aa) { return new ActionArgument(aa); });
        }
        else if (action.actionType === ActionTypes.API_LOCAL) {
            var actionPayload = JSON.parse(action.payload);
            return actionPayload.logicArguments.concat(actionPayload.renderArguments).map(function (aa) { return new ActionArgument(aa); });
        }
        return [];
    };
    return ActionBase;
}());
var ActionArgument = /** @class */ (function () {
    function ActionArgument(actionArgument) {
        this.parameter = actionArgument.parameter;
        this.value = actionArgument.value.json;
    }
    ActionArgument.prototype.renderValue = function (entityValues, serializerOptions) {
        if (serializerOptions === void 0) { serializerOptions = {}; }
        return EntityIdSerializer.serialize(this.value, entityValues, serializerOptions);
    };
    return ActionArgument;
}());
var TextAction = /** @class */ (function (_super) {
    __extends(TextAction, _super);
    function TextAction(action) {
        var _this = _super.call(this, action) || this;
        if (action.actionType !== ActionTypes.TEXT) {
            throw new Error("You attempted to create text action from action of type: " + action.actionType);
        }
        _this.value = JSON.parse(_this.payload).json;
        return _this;
    }
    TextAction.prototype.renderValue = function (entityValues, serializerOptions) {
        if (serializerOptions === void 0) { serializerOptions = {}; }
        return EntityIdSerializer.serialize(this.value, entityValues, serializerOptions);
    };
    return TextAction;
}(ActionBase));
var ApiAction = /** @class */ (function (_super) {
    __extends(ApiAction, _super);
    function ApiAction(action) {
        var _this = _super.call(this, action) || this;
        if (action.actionType !== ActionTypes.API_LOCAL) {
            throw new Error("You attempted to create api action from action of type: " + action.actionType);
        }
        var actionPayload = JSON.parse(_this.payload);
        _this.name = actionPayload.payload;
        _this.logicArguments = actionPayload.logicArguments.map(function (aa) { return new ActionArgument(aa); });
        _this.renderArguments = actionPayload.renderArguments.map(function (aa) { return new ActionArgument(aa); });
        return _this;
    }
    ApiAction.prototype.renderLogicArguments = function (entityValues, serializerOptions) {
        if (serializerOptions === void 0) { serializerOptions = {}; }
        return this.renderArgs(this.logicArguments, entityValues, serializerOptions);
    };
    ApiAction.prototype.renderRenderArguments = function (entityValues, serializerOptions) {
        if (serializerOptions === void 0) { serializerOptions = {}; }
        return this.renderArgs(this.renderArguments, entityValues, serializerOptions);
    };
    ApiAction.prototype.renderArgs = function (args, entityValues, serializerOptions) {
        if (serializerOptions === void 0) { serializerOptions = {}; }
        return args.map(function (aa) {
            var value = null;
            try {
                value = EntityIdSerializer.serialize(aa.value, entityValues, serializerOptions);
            }
            catch (error) {
                // Just return null if argument doesn't have a value
            }
            return __assign({}, aa, { value: value });
        });
    };
    return ApiAction;
}(ActionBase));
var CardAction = /** @class */ (function (_super) {
    __extends(CardAction, _super);
    function CardAction(action) {
        var _this = _super.call(this, action) || this;
        if (action.actionType !== ActionTypes.CARD) {
            throw new Error("You attempted to create card action from action of type: " + action.actionType);
        }
        var payload = JSON.parse(_this.payload);
        _this.templateName = payload.payload;
        _this.arguments = payload.arguments.map(function (aa) { return new ActionArgument(aa); });
        return _this;
    }
    CardAction.prototype.renderArguments = function (entityValues, serializerOptions) {
        if (serializerOptions === void 0) { serializerOptions = {}; }
        return this.arguments.map(function (aa) {
            var value = null;
            try {
                value = EntityIdSerializer.serialize(aa.value, entityValues, serializerOptions);
            }
            catch (error) {
                // Just return null if argument doesn't have a value
            }
            return __assign({}, aa, { value: value });
        });
    };
    return CardAction;
}(ActionBase));
var SessionAction = /** @class */ (function (_super) {
    __extends(SessionAction, _super);
    function SessionAction(action) {
        var _this = _super.call(this, action) || this;
        if (action.actionType !== ActionTypes.END_SESSION) {
            throw new Error("You attempted to create session action from action of type: " + action.actionType);
        }
        _this.value = JSON.parse(_this.payload).json;
        return _this;
    }
    SessionAction.prototype.renderValue = function (entityValues, serializerOptions) {
        if (serializerOptions === void 0) { serializerOptions = {}; }
        return EntityIdSerializer.serialize(this.value, entityValues, serializerOptions);
    };
    return SessionAction;
}(ActionBase));

var TrainingStatusCode;
(function (TrainingStatusCode) {
    TrainingStatusCode["Queued"] = "queued";
    TrainingStatusCode["Running"] = "running";
    TrainingStatusCode["Completed"] = "completed";
    TrainingStatusCode["Failed"] = "failed";
})(TrainingStatusCode || (TrainingStatusCode = {}));

/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var EntityType;
(function (EntityType) {
    EntityType["LOCAL"] = "LOCAL";
    EntityType["LUIS"] = "LUIS";
})(EntityType || (EntityType = {}));
var makeNegative = function (entity, positiveId) { return (__assign({}, entity, { negativeId: null, positiveId: positiveId })); };

var SenderType;
(function (SenderType) {
    SenderType[SenderType["User"] = 0] = "User";
    SenderType[SenderType["Bot"] = 1] = "Bot";
})(SenderType || (SenderType = {}));

var ModelUtils = /** @class */ (function () {
    function ModelUtils() {
    }
    ModelUtils.generateGUID = function () {
        var d = new Date().getTime();
        var guid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (char) {
            var r = ((d + Math.random() * 16) % 16) | 0;
            d = Math.floor(d / 16);
            return (char === 'x' ? r : (r & 0x3) | 0x8).toString(16);
        });
        return guid;
    };
    /** Remove n words from start of string */
    ModelUtils.RemoveWords = function (text, numWords) {
        if (text.length === 0 || numWords === 0) {
            return text;
        }
        var firstSpace = text.indexOf(' ');
        var remaining = firstSpace > 0 ? text.slice(firstSpace + 1) : '';
        numWords--;
        return this.RemoveWords(remaining, numWords);
    };
    //====================================================================
    // CONVERSION: LabeledEntity == PredictedEntity
    //====================================================================
    ModelUtils.ToLabeledEntity = function (predictedEntity) {
        var score = predictedEntity.score, labeledEntity = __rest(predictedEntity, ["score"]);
        return predictedEntity;
    };
    ModelUtils.ToLabeledEntities = function (predictedEntities) {
        var labeledEntities = [];
        for (var _i = 0, predictedEntities_1 = predictedEntities; _i < predictedEntities_1.length; _i++) {
            var predictedEntity = predictedEntities_1[_i];
            var labelEntity = ModelUtils.ToLabeledEntity(predictedEntity);
            labeledEntities.push(labelEntity);
        }
        return labeledEntities;
    };
    ModelUtils.ToPredictedEntity = function (labeledEntity) {
        return __assign({}, labeledEntity, { score: undefined });
    };
    ModelUtils.ToPredictedEntities = function (labeledEntities) {
        var predictedEntities = [];
        for (var _i = 0, labeledEntities_1 = labeledEntities; _i < labeledEntities_1.length; _i++) {
            var labeledEntity = labeledEntities_1[_i];
            var predictedEntity = ModelUtils.ToPredictedEntity(labeledEntity);
            predictedEntities.push(predictedEntity);
        }
        return predictedEntities;
    };
    //====================================================================
    // CONVERSION: ExtractResponse == TextVariation
    //====================================================================
    ModelUtils.ToTextVariation = function (extractResponse) {
        var labeledEntities = this.ToLabeledEntities(extractResponse.predictedEntities);
        var textVariation = {
            text: extractResponse.text,
            labelEntities: labeledEntities
        };
        return textVariation;
    };
    ModelUtils.ToExtractResponses = function (textVariations) {
        var extractResponses = [];
        for (var _i = 0, textVariations_1 = textVariations; _i < textVariations_1.length; _i++) {
            var textVariation = textVariations_1[_i];
            var predictedEntities = this.ToPredictedEntities(textVariation.labelEntities);
            var extractResponse = {
                definitions: {
                    entities: [],
                    actions: [],
                    trainDialogs: []
                },
                packageId: '',
                metrics: {
                    wallTime: 0
                },
                text: textVariation.text,
                predictedEntities: predictedEntities
            };
            extractResponses.push(extractResponse);
        }
        return extractResponses;
    };
    ModelUtils.ToTextVariations = function (extractResponses) {
        var textVariations = [];
        for (var _i = 0, extractResponses_1 = extractResponses; _i < extractResponses_1.length; _i++) {
            var extractResponse = extractResponses_1[_i];
            var labelEntities = this.ToLabeledEntities(extractResponse.predictedEntities);
            var textVariation = {
                text: extractResponse.text,
                labelEntities: labelEntities
            };
            textVariations.push(textVariation);
        }
        return textVariations;
    };
    //====================================================================
    // CONVERSION: LogDialog == TrainDialog
    //====================================================================
    ModelUtils.ToTrainDialog = function (logDialog, actions, entities) {
        if (actions === void 0) { actions = null; }
        if (entities === void 0) { entities = null; }
        var trainRounds = [];
        for (var _i = 0, _a = logDialog.rounds; _i < _a.length; _i++) {
            var logRound = _a[_i];
            var trainRound = ModelUtils.ToTrainRound(logRound);
            trainRounds.push(trainRound);
        }
        var appDefinition = null;
        if (entities != null && actions != null) {
            appDefinition = {
                entities: entities,
                actions: actions,
                trainDialogs: []
            };
        }
        return {
            createdDateTime: logDialog.createdDateTime,
            lastModifiedDateTime: logDialog.lastModifiedDateTime,
            packageCreationId: 0,
            packageDeletionId: 0,
            trainDialogId: '',
            sourceLogDialogId: logDialog.logDialogId,
            version: 0,
            rounds: trainRounds,
            definitions: appDefinition,
            initialFilledEntities: logDialog.initialFilledEntities
        };
    };
    //====================================================================
    // CONVERSION: LogRoung == TrainRound
    //====================================================================
    ModelUtils.ToTrainRound = function (logRound) {
        return {
            extractorStep: {
                textVariations: [
                    {
                        labelEntities: ModelUtils.ToLabeledEntities(logRound.extractorStep.predictedEntities),
                        text: logRound.extractorStep.text
                    }
                ]
            },
            scorerSteps: logRound.scorerSteps.map(function (logScorerStep) { return ({
                input: logScorerStep.input,
                labelAction: logScorerStep.predictedAction,
                logicResult: undefined,
                scoredAction: undefined
            }); })
        };
    };
    //====================================================================
    // CONVERSION: LogScorerStep == TrainScorerStep
    //====================================================================
    ModelUtils.ToTrainScorerStep = function (logScorerStep) {
        return {
            input: logScorerStep.input,
            labelAction: logScorerStep.predictedAction,
            logicResult: undefined,
            scoredAction: undefined
        };
    };
    //====================================================================
    // CONVERSION: TrainDialog == CreateTeachParams
    //====================================================================
    ModelUtils.ToCreateTeachParams = function (trainDialog) {
        var createTeachParams = {
            contextDialog: trainDialog.rounds,
            sourceLogDialogId: trainDialog.sourceLogDialogId,
            initialFilledEntities: trainDialog.initialFilledEntities
        };
        // TODO: Change to non destructive operation
        // Strip out "entityType" (*sigh*)
        for (var _i = 0, _a = createTeachParams.contextDialog; _i < _a.length; _i++) {
            var round = _a[_i];
            for (var _b = 0, _c = round.extractorStep.textVariations; _b < _c.length; _b++) {
                var textVariation = _c[_b];
                for (var _d = 0, _e = textVariation.labelEntities; _d < _e.length; _d++) {
                    var labeledEntity = _e[_d];
                    delete labeledEntity.entityType;
                }
            }
        }
        return createTeachParams;
    };
    //====================================================================
    // CONVERSION: TeachResponse == Teach
    //====================================================================
    ModelUtils.ToTeach = function (teachResponse) {
        return {
            teachId: teachResponse.teachId,
            trainDialogId: teachResponse.trainDialogId,
            createdDatetime: undefined,
            lastQueryDatetime: undefined,
            packageId: undefined
        };
    };
    //====================================================================
    // Misc utils shared between SDK and UI
    //====================================================================
    /* Converts user intput into BB.Activity */
    ModelUtils.InputToActivity = function (userText, userName, userId, roundNum) {
        // Generate activity
        return {
            id: this.generateGUID(),
            from: { id: userId, name: userName },
            channelData: {
                senderType: SenderType.User,
                roundIndex: roundNum,
                scoreIndex: 0,
                clientActivityId: this.generateGUID()
            },
            type: 'message',
            text: userText
        };
    };
    ModelUtils.PrebuiltDisplayText = function (builtinType, resolution, entityText) {
        if (!builtinType || !resolution) {
            return entityText;
        }
        if (['builtin.geography', 'builtin.encyclopedia'].some(function (prefix) { return builtinType.startsWith(prefix); })) {
            return entityText;
        }
        switch (builtinType) {
            case 'builtin.datetimeV2.date':
                var date = resolution.values[0].value;
                if (resolution.values[1]) {
                    date += " or " + resolution.values[1].value;
                }
                return date;
            case 'builtin.datetimeV2.time':
                var time = resolution.values[0].value;
                if (resolution.values[1]) {
                    time += " or " + resolution.values[1].value;
                }
                return time;
            case 'builtin.datetimeV2.daterange':
                return resolution.values[0].start + " to " + resolution.values[0].end;
            case 'builtin.datetimeV2.timerange':
                return resolution.values[0].start + " to " + resolution.values[0].end;
            case 'builtin.datetimeV2.datetimerange':
                return resolution.values[0].start + " to " + resolution.values[0].end;
            case 'builtin.datetimeV2.duration':
                return resolution.values[0].value + " seconds";
            case 'builtin.datetimeV2.set':
                return "" + resolution.values[0].value;
            case 'builtin.number':
                return resolution.value;
            case 'builtin.ordinal':
                return resolution.value;
            case 'builtin.temperature':
                return resolution.value;
            case 'builtin.dimension':
                return resolution.value;
            case 'builtin.money':
                return resolution.value;
            case 'builtin.age':
                return resolution.value;
            case 'builtin.percentage':
                return resolution.value;
            default:
                return entityText;
        }
    };
    return ModelUtils;
}());

var filledEntityValueAsString = function (fe) { return memoryValuesAsString(fe.values); };
var memoryValuesAsString = function (memories) {
    // Print out list in friendly manner
    var group = '';
    for (var key in memories) {
        var index = +key;
        var prefix = '';
        if (memories.length !== 1 && index === memories.length - 1) {
            prefix = ' and ';
        }
        else if (index !== 0) {
            prefix = ', ';
        }
        var value = memories[key];
        var text = value.displayText ? value.displayText : value.userText;
        group += "" + prefix + text;
    }
    return group;
};
// In future will refactor to remove FilledEntityMap, but this method provides abstraction
// or isolation to methods that would normally consume filledEntityMap to reduce coupling
// and make code more flexible
var getEntityDisplayValueMap = function (filledEntityMap) {
    return Object.keys(filledEntityMap.map).reduce(function (m, key) {
        var entityDisplayValue = filledEntityMap.ValueAsString(key);
        // TODO: Required check because poor API from filledEntityMap which can return null
        if (entityDisplayValue) {
            m.set(key, entityDisplayValue);
        }
        return m;
    }, new Map());
};
var FilledEntityMap = /** @class */ (function () {
    function FilledEntityMap(init) {
        this.map = {};
        Object.assign(this, init);
    }
    FilledEntityMap.FromFilledEntities = function (filledEntities, entities) {
        var filledEntityMap = new FilledEntityMap();
        var _loop_1 = function (filledEntity) {
            var entity = entities.find(function (e) { return e.entityId === filledEntity.entityId; });
            if (entity) {
                filledEntityMap.map[entity.entityName] = filledEntity;
            }
        };
        for (var _i = 0, filledEntities_1 = filledEntities; _i < filledEntities_1.length; _i++) {
            var filledEntity = filledEntities_1[_i];
            _loop_1(filledEntity);
        }
        return filledEntityMap;
    };
    FilledEntityMap.prototype.ValueAsList = function (entityName) {
        if (!this.map[entityName]) {
            return [];
        }
        return this.map[entityName].values.filter(function (v) { return typeof v.userText === 'string'; }).map(function (v) { return v.userText; });
    };
    FilledEntityMap.prototype.ValueAsString = function (entityName) {
        if (!this.map[entityName]) {
            return null;
        }
        // Print out list in friendly manner
        return filledEntityValueAsString(this.map[entityName]);
    };
    FilledEntityMap.prototype.ValueAsNumber = function (entityName) {
        var textObj = this.ValueAsString(entityName);
        var number = Number(textObj);
        if (isNaN(number)) {
            return null;
        }
        return number;
    };
    FilledEntityMap.prototype.ValueAsBoolean = function (entityName) {
        var textObj = this.ValueAsString(entityName);
        if (textObj) {
            if (textObj.toLowerCase() === 'true') {
                return true;
            }
            if (textObj.toLowerCase() === 'false') {
                return false;
            }
        }
        return null;
    };
    FilledEntityMap.prototype.ValueAsObject = function (entityName) {
        var textObj = this.ValueAsString(entityName);
        if (textObj) {
            return JSON.parse(textObj);
        }
        return null;
    };
    FilledEntityMap.prototype.ValueAsPrebuilt = function (entityName) {
        if (!this.map[entityName]) {
            return [];
        }
        return this.map[entityName].values;
    };
    FilledEntityMap.prototype.Forget = function (entityName, entityValue, isBucket) {
        if (entityValue === void 0) { entityValue = null; }
        if (isBucket === void 0) { isBucket = false; }
        // Check if entity buckets values
        if (isBucket) {
            // Entity might not be in memory
            if (!this.map[entityName]) {
                return;
            }
            // If no entity Value provide, clear the entity
            if (!entityValue) {
                delete this.map[entityName];
            }
            else {
                // Find case insensitive index
                var lowerCaseNames = this.map[entityName].values.filter(function (mv) { return mv.userText; }).map(function (mv) { return mv.userText.toLowerCase(); });
                var index = lowerCaseNames.indexOf(entityValue.toLowerCase());
                if (index > -1) {
                    this.map[entityName].values.splice(index, 1);
                    if (this.map[entityName].values.length === 0) {
                        delete this.map[entityName];
                    }
                }
            }
        }
        else {
            delete this.map[entityName];
        }
    };
    // Remember multiple values for an entity
    FilledEntityMap.prototype.RememberMany = function (entityName, entityId, entityValues, isBucket, builtinType, resolution) {
        if (isBucket === void 0) { isBucket = false; }
        if (builtinType === void 0) { builtinType = null; }
        if (resolution === void 0) { resolution = null; }
        for (var _i = 0, entityValues_1 = entityValues; _i < entityValues_1.length; _i++) {
            var entityValue = entityValues_1[_i];
            this.Remember(entityName, entityId, entityValue, isBucket, builtinType, resolution);
        }
    };
    // Remember value for an entity
    FilledEntityMap.prototype.Remember = function (entityName, entityId, entityValue, isBucket, builtinType, resolution) {
        if (isBucket === void 0) { isBucket = false; }
        if (builtinType === void 0) { builtinType = null; }
        if (resolution === void 0) { resolution = null; }
        // If we don't already have entry in map for this item, create one
        if (!this.map[entityName]) {
            this.map[entityName] = {
                entityId: entityId,
                values: []
            };
        }
        var displayText = builtinType && resolution ? ModelUtils.PrebuiltDisplayText(builtinType, resolution, entityValue) : entityValue;
        var newFilledEntityValue = {
            userText: entityValue,
            displayText: displayText,
            builtinType: builtinType,
            resolution: resolution
        };
        var filledEntity = this.map[entityName];
        // Check if entity buckets values
        if (isBucket) {
            // Add if not a duplicate
            var containsDuplicateValue = filledEntity.values.some(function (memoryValue) { return memoryValue.userText === entityValue; });
            if (!containsDuplicateValue) {
                filledEntity.values.push(newFilledEntityValue);
            }
        }
        else {
            filledEntity.values = [newFilledEntityValue];
        }
    };
    /** Return FilledEntity array for items I've remembered */
    FilledEntityMap.prototype.FilledEntities = function () {
        var _this = this;
        return Object.keys(this.map).map(function (val) {
            return _this.map[val];
        });
    };
    FilledEntityMap.Split = function (action) {
        return action.split(/[\s,:.?!\[\]]+/);
    };
    return FilledEntityMap;
}());

/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var KeyGen = /** @class */ (function () {
    function KeyGen() {
    }
    KeyGen.MakeKey = function (address) {
        return this.HashCode(address).toString();
    };
    KeyGen.HashCode = function (text) {
        var hash = 0;
        var i = undefined;
        var chr = undefined;
        if (text.length === 0)
            return hash;
        for (i = 0; i < text.length; i++) {
            chr = text.charCodeAt(i);
            hash = (hash << 5) - hash + chr;
            hash |= 0; // Convert to 32bit integer
        }
        return hash;
    };
    return KeyGen;
}());

/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
var ReplayErrorType;
(function (ReplayErrorType) {
    /* Action does not exist in the model */
    ReplayErrorType["ActionUndefined"] = "ActionUndefined";
    /* Entity does not exist in the model */
    ReplayErrorType["EntityUndefined"] = "EntityUndefined";
    /* Entity used in Action but has not value */
    ReplayErrorType["EntityEmpty"] = "EntityEmpty";
    /* Selected Action is not available with given constraints */
    ReplayErrorType["ActionUnavailable"] = "ActionUnavailable";
    ReplayErrorType["EntityDiscrepancy"] = "EntityDiscrepancy";
    /* Action in Score Rounds after Wait action */
    ReplayErrorType["ActionAfterWait"] = "ActionAfterWait";
    /* Two consecutive user inputs */
    ReplayErrorType["TwoUserInputs"] = "TwoUserInputs";
    /* User input after non-wait */
    ReplayErrorType["InputAfterNonWait"] = "InputAfterNonWait";
})(ReplayErrorType || (ReplayErrorType = {}));
var ReplayError = /** @class */ (function () {
    function ReplayError(type) {
        this.type = type;
    }
    return ReplayError;
}());
var ReplayErrorActionUndefined = /** @class */ (function (_super) {
    __extends(ReplayErrorActionUndefined, _super);
    function ReplayErrorActionUndefined(lastUserInput) {
        var _this = _super.call(this, ReplayErrorType.ActionUndefined) || this;
        _this.lastUserInput = lastUserInput;
        return _this;
    }
    return ReplayErrorActionUndefined;
}(ReplayError));
var ReplayErrorEntityUndefined = /** @class */ (function (_super) {
    __extends(ReplayErrorEntityUndefined, _super);
    function ReplayErrorEntityUndefined(value) {
        var _this = _super.call(this, ReplayErrorType.EntityUndefined) || this;
        _this.value = value;
        return _this;
    }
    return ReplayErrorEntityUndefined;
}(ReplayError));
var ReplayErrorEntityEmpty = /** @class */ (function (_super) {
    __extends(ReplayErrorEntityEmpty, _super);
    function ReplayErrorEntityEmpty(values) {
        var _this = _super.call(this, ReplayErrorType.EntityEmpty) || this;
        _this.values = values;
        return _this;
    }
    return ReplayErrorEntityEmpty;
}(ReplayError));
var ReplayErrorActionUnavailable = /** @class */ (function (_super) {
    __extends(ReplayErrorActionUnavailable, _super);
    function ReplayErrorActionUnavailable(lastUserInput) {
        var _this = _super.call(this, ReplayErrorType.ActionUnavailable) || this;
        _this.lastUserInput = lastUserInput;
        return _this;
    }
    return ReplayErrorActionUnavailable;
}(ReplayError));
var ReplayErrorEntityDiscrepancy = /** @class */ (function (_super) {
    __extends(ReplayErrorEntityDiscrepancy, _super);
    function ReplayErrorEntityDiscrepancy(lastUserInput, originalEntities, newEntities) {
        var _this = _super.call(this, ReplayErrorType.EntityDiscrepancy) || this;
        _this.lastUserInput = lastUserInput;
        _this.originalEntities = originalEntities;
        _this.newEntities = newEntities;
        return _this;
    }
    return ReplayErrorEntityDiscrepancy;
}(ReplayError));
var ReplayErrorActionAfterWait = /** @class */ (function (_super) {
    __extends(ReplayErrorActionAfterWait, _super);
    function ReplayErrorActionAfterWait() {
        return _super.call(this, ReplayErrorType.ActionAfterWait) || this;
    }
    return ReplayErrorActionAfterWait;
}(ReplayError));
var ReplayErrorTwoUserInputs = /** @class */ (function (_super) {
    __extends(ReplayErrorTwoUserInputs, _super);
    function ReplayErrorTwoUserInputs() {
        return _super.call(this, ReplayErrorType.TwoUserInputs) || this;
    }
    return ReplayErrorTwoUserInputs;
}(ReplayError));
var ReplayErrorInputAfterNonWait = /** @class */ (function (_super) {
    __extends(ReplayErrorInputAfterNonWait, _super);
    function ReplayErrorInputAfterNonWait() {
        return _super.call(this, ReplayErrorType.InputAfterNonWait) || this;
    }
    return ReplayErrorInputAfterNonWait;
}(ReplayError));

var DialogType;
(function (DialogType) {
    DialogType["TEACH"] = "teach";
    DialogType["TRAINDIALOG"] = "traindialog";
    DialogType["LOGDIALOG"] = "logdialog";
})(DialogType || (DialogType = {}));

var DialogMode;
(function (DialogMode) {
    DialogMode["Extractor"] = "Extract";
    DialogMode["Scorer"] = "Score";
    DialogMode["Wait"] = "Wait";
    DialogMode["EndSession"] = "EndSession"; // Dialog is over - EndSesssion Action has been called
})(DialogMode || (DialogMode = {}));

var CL_USER_NAME_ID = 'CLTrainer';
var MEMORY_KEY_HEADER_NAME = 'x-conversationlearner-memory-key';
/** Indicates whether END_SESSION was called on the running Session */
var SessionEndState;
(function (SessionEndState) {
    /** Session ended because END_SESSION activity has been called */
    SessionEndState["COMPLETED"] = "completed";
    /** Session ended because of timeout or new session started w/o END_SESSION activity */
    SessionEndState["OPEN"] = "open";
})(SessionEndState || (SessionEndState = {}));
var ScoreReason;
(function (ScoreReason) {
    // Action has been masked
    ScoreReason["NotAvailable"] = "notAvailable";
    // Action can't be scored because it hasn't been trained yet
    ScoreReason["NotScorable"] = "notScorable";
    // Score has not yet been calculated
    ScoreReason["NotCalculated"] = "notCalculated";
})(ScoreReason || (ScoreReason = {}));

/**
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

export { EntityIdSerializer, ActionTypes, ActionBase, ActionArgument, TextAction, ApiAction, CardAction, SessionAction, TrainingStatusCode, EntityType, makeNegative, filledEntityValueAsString, memoryValuesAsString, getEntityDisplayValueMap, FilledEntityMap, KeyGen, ModelUtils, ReplayErrorType, ReplayError, ReplayErrorActionUndefined, ReplayErrorEntityUndefined, ReplayErrorEntityEmpty, ReplayErrorActionUnavailable, ReplayErrorEntityDiscrepancy, ReplayErrorActionAfterWait, ReplayErrorTwoUserInputs, ReplayErrorInputAfterNonWait, DialogType, DialogMode, SenderType, CL_USER_NAME_ID, MEMORY_KEY_HEADER_NAME, SessionEndState, ScoreReason };
//# sourceMappingURL=conversationlearner-models.es5.js.map
